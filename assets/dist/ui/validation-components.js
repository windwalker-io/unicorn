/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["UnicornValidation"] = factory();
	else
		root["UnicornValidation"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../../../node_modules/punycode/punycode.es6.js":
/*!*********************************************************!*\
  !*** ../../../../node_modules/punycode/punycode.es6.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   toASCII: () => (/* binding */ toASCII),\n/* harmony export */   toUnicode: () => (/* binding */ toUnicode),\n/* harmony export */   ucs2decode: () => (/* binding */ ucs2decode),\n/* harmony export */   ucs2encode: () => (/* binding */ ucs2encode)\n/* harmony export */ });\n\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (punycode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLi9zcmMvbW9kdWxlcy91aS92YWxpZGF0aW9uLWNvbXBvbmVudHMudHMvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcz8yMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCB0TWluID0gMTtcbmNvbnN0IHRNYXggPSAyNjtcbmNvbnN0IHNrZXcgPSAzODtcbmNvbnN0IGRhbXAgPSA3MDA7XG5jb25zdCBpbml0aWFsQmlhcyA9IDcyO1xuY29uc3QgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbmNvbnN0IGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuY29uc3QgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdGXS87IC8vIE5vdGU6IFUrMDA3RiBERUwgaXMgZXhjbHVkZWQgdG9vLlxuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbmNvbnN0IGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbmNvbnN0IGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBjYWxsYmFjaykge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBjYWxsYmFjayhhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihkb21haW4sIGNhbGxiYWNrKSB7XG5cdGNvbnN0IHBhcnRzID0gZG9tYWluLnNwbGl0KCdAJyk7XG5cdGxldCByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRkb21haW4gPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdGRvbWFpbiA9IGRvbWFpbi5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdGNvbnN0IGxhYmVscyA9IGRvbWFpbi5zcGxpdCgnLicpO1xuXHRjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgY2FsbGJhY2spLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRsZXQgY291bnRlciA9IDA7XG5cdGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuY29uc3QgdWNzMmVuY29kZSA9IGNvZGVQb2ludHMgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xuY29uc3QgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHgzMCAmJiBjb2RlUG9pbnQgPCAweDNBKSB7XG5cdFx0cmV0dXJuIDI2ICsgKGNvZGVQb2ludCAtIDB4MzApO1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgPj0gMHg0MSAmJiBjb2RlUG9pbnQgPCAweDVCKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCA+PSAweDYxICYmIGNvZGVQb2ludCA8IDB4N0IpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xuY29uc3QgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0bGV0IGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0bGV0IGkgPSAwO1xuXHRsZXQgbiA9IGluaXRpYWxOO1xuXHRsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yIChsZXQgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0Y29uc3Qgb2xkaSA9IGk7XG5cdFx0Zm9yIChsZXQgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdGlmIChkaWdpdCA+PSBiYXNlKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGRlbHRhID0gMDtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHRsZXQgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRsZXQgbSA9IG1heEludDtcblx0XHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG5cdFx0Y29uc3QgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID09PSBuKSB7XG5cdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRsZXQgcSA9IGRlbHRhO1xuXHRcdFx0XHRmb3IgKGxldCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblxuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG5jb25zdCB0b1VuaWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuY29uc3QgdG9BU0NJSSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQndmVyc2lvbic6ICcyLjMuMScsXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG5leHBvcnQgeyB1Y3MyZGVjb2RlLCB1Y3MyZW5jb2RlLCBkZWNvZGUsIGVuY29kZSwgdG9BU0NJSSwgdG9Vbmljb2RlIH07XG5leHBvcnQgZGVmYXVsdCBwdW55Y29kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../node_modules/punycode/punycode.es6.js\n");

/***/ }),

/***/ "./src/modules/ui/validation-components.ts":
/*!*************************************************!*\
  !*** ./src/modules/ui/validation-components.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnicornFieldValidation: () => (/* binding */ UnicornFieldValidation),\n/* harmony export */   UnicornFormValidation: () => (/* binding */ UnicornFormValidation),\n/* harmony export */   initValidations: () => (/* binding */ initValidations),\n/* harmony export */   validators: () => (/* binding */ validatorHandlers)\n/* harmony export */ });\n/* harmony import */ var punycode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! punycode */ \"../../../../node_modules/punycode/punycode.es6.js\");\n\nconst validatorHandlers = {};\nconst defaultOptions = {\n    scroll: false,\n    scrollOffset: -100,\n    enabled: true,\n    fieldSelector: null,\n    validatedClass: null,\n};\nconst defaultFieldOptions = {\n    formSelector: '[uni-form-validate]',\n    errorSelector: '[data-field-error]',\n    selector: 'input[data-field-input], select[data-field-input], textarea[data-field-input]',\n    validClass: 'is-valid',\n    invalidClass: 'is-invalid',\n    events: ['change'],\n    errorMessageClass: 'invalid-tooltip',\n    inputOptions: false,\n    inputOptionsWrapperSelector: 'div[data-field-input]',\n    inputOptionsSelector: '[data-input-option]'\n};\nclass UnicornFormValidation {\n    app;\n    presetFields = [];\n    static globalValidators = {};\n    validators = {};\n    options;\n    $form;\n    static is = 'uni-form-validate';\n    constructor(app, el, options = {}) {\n        this.app = app;\n        this.$form = this.$helper.selectOne(el);\n        this.options = this.$helper.defaultsDeep({}, options, defaultOptions);\n        this.registerDefaultValidators();\n        this.init();\n    }\n    get $helper() {\n        return this.app.inject('$helper');\n    }\n    get $ui() {\n        return this.app.inject('$ui');\n    }\n    get $lang() {\n        return this.app.inject('$lang');\n    }\n    setOptions(options) {\n        this.options = this.$helper.defaultsDeep({}, options, defaultOptions);\n    }\n    get scrollEnabled() {\n        return this.options.scroll;\n    }\n    get scrollOffset() {\n        return Number(this.options.scrollOffset || -100);\n    }\n    get fieldSelector() {\n        return this.options.fieldSelector || 'input, select, textarea';\n    }\n    get validatedClass() {\n        return this.options.validatedClass || 'was-validated';\n    }\n    init() {\n        if (this.$form.tagName === 'FORM') {\n            this.$form.setAttribute('novalidate', 'true');\n            this.$form.addEventListener('submit', (event) => {\n                if (this.options.enabled && !this.validateAll()) {\n                    event.stopImmediatePropagation(); // Stop following events\n                    event.stopPropagation();\n                    event.preventDefault();\n                    this.$form.dispatchEvent(new CustomEvent('invalid'));\n                    return false;\n                }\n                return true;\n            }, false);\n        }\n        this.prepareFields(this.findDOMFields());\n        this.prepareFields(this.presetFields);\n    }\n    findDOMFields() {\n        return this.$helper.selectAll(this.$form.querySelectorAll(this.fieldSelector));\n    }\n    prepareFields(inputs) {\n        inputs.forEach((input) => {\n            this.prepareFieldWrapper(input);\n        });\n        // Wait next tick\n        return Promise.resolve();\n    }\n    prepareFieldWrapper(input) {\n        if (['INPUT', 'SELECT', 'TEXTAREA'].indexOf(input.tagName) !== -1) {\n            let wrapper = input.closest('[uni-field-validate]');\n            if (!wrapper) {\n                wrapper = input.closest('[data-input-container]') || input.parentElement;\n                wrapper?.setAttribute('uni-field-validate', '{}');\n            }\n            return wrapper;\n        }\n        return input;\n    }\n    findFields(containsPresets = true) {\n        let inputs = this.findDOMFields();\n        if (containsPresets) {\n            inputs.push(...this.presetFields);\n        }\n        return inputs.map((input) => this.prepareFieldWrapper(input))\n            .filter(input => input != null);\n    }\n    getFieldComponent(input) {\n        let v = this.$helper.getBoundedInstance(input, 'field.validation');\n        if (!v) {\n            const wrapper = input.closest('[uni-field-validate]');\n            if (wrapper) {\n                v = this.$helper.getBoundedInstance(wrapper, 'field.validation');\n            }\n        }\n        return v;\n    }\n    validateAll(fields) {\n        this.markFormAsUnvalidated();\n        fields = fields || this.findFields();\n        let firstFail = null;\n        for (const field of fields) {\n            const fv = this.getFieldComponent(field);\n            if (!fv) {\n                continue;\n            }\n            const result = fv.checkValidity();\n            if (!result && !firstFail) {\n                firstFail = field;\n            }\n        }\n        this.markFormAsValidated();\n        if (firstFail && this.scrollEnabled) {\n            this.scrollTo(firstFail);\n        }\n        return firstFail === null;\n    }\n    async validateAllAsync(fields) {\n        this.markFormAsUnvalidated();\n        fields = fields || this.findFields();\n        let firstFail = null;\n        const promises = [];\n        for (const field of fields) {\n            const fv = this.getFieldComponent(field);\n            if (!fv) {\n                continue;\n            }\n            promises.push(fv.checkValidityAsync().then((result) => {\n                if (!result && !firstFail) {\n                    firstFail = field;\n                }\n                return result;\n            }));\n        }\n        await Promise.all(promises);\n        this.markFormAsValidated();\n        if (firstFail && this.scrollEnabled) {\n            this.scrollTo(firstFail);\n        }\n        return firstFail === null;\n    }\n    scrollTo(element) {\n        const offset = this.scrollOffset;\n        const elementPosition = element.getBoundingClientRect().top;\n        const offsetPosition = elementPosition + window.scrollY + offset;\n        window.scrollTo({\n            top: offsetPosition,\n            behavior: 'smooth'\n        });\n    }\n    markFormAsValidated() {\n        if (!this.$form) {\n            return;\n        }\n        this.$form.classList.add(this.validatedClass);\n    }\n    markFormAsUnvalidated() {\n        if (!this.$form) {\n            return;\n        }\n        this.$form.classList.remove(this.validatedClass);\n    }\n    addField(field) {\n        this.presetFields.push(field);\n        this.prepareFieldWrapper(field);\n        return this;\n    }\n    registerDefaultValidators() {\n        for (let name in validatorHandlers) {\n            this.addValidator(name, validatorHandlers[name]);\n        }\n    }\n    /**\n     * Add validator handler.\n     */\n    addValidator(name, handler, options = {}) {\n        options = options || {};\n        this.validators[name] = {\n            handler,\n            options\n        };\n        return this;\n    }\n    /**\n     * Add validator handler.\n     */\n    static addGlobalValidator(name, handler, options = {}) {\n        options = options || {};\n        this.globalValidators[name] = {\n            handler,\n            options\n        };\n        return this;\n    }\n}\nclass UnicornFieldValidation {\n    app;\n    el;\n    $input;\n    options;\n    static is = 'uni-field-validate';\n    constructor(app, el, options = {}) {\n        this.app = app;\n        this.el = el;\n        this.options = this.$helper.defaultsDeep({}, options, defaultFieldOptions);\n        this.$input = this.selectInput();\n        this.init();\n    }\n    get $helper() {\n        return this.app.inject('$helper');\n    }\n    get $lang() {\n        return this.app.inject('$lang');\n    }\n    get $ui() {\n        return this.app.inject('$ui');\n    }\n    setOptions(options) {\n        this.options = this.$helper.defaultsDeep({}, options, defaultFieldOptions);\n    }\n    get $form() {\n        return this.getForm();\n    }\n    get errorSelector() {\n        return this.options.errorSelector;\n    }\n    get selector() {\n        return this.options.selector;\n    }\n    get validClass() {\n        return this.options.validClass;\n    }\n    get invalidClass() {\n        return this.options.invalidClass;\n    }\n    get isVisible() {\n        return !!(this.el.offsetWidth || this.el.offsetHeight || this.el.getClientRects().length);\n    }\n    get isInputOptions() {\n        return Boolean(this.options.inputOptions);\n    }\n    get validationMessage() {\n        return this.$input?.validationMessage || '';\n    }\n    get validity() {\n        return this.$input?.validity;\n    }\n    selectInput() {\n        let selector = this.selector;\n        if (this.options.inputOptions) {\n            selector += ', ' + this.options.inputOptionsWrapperSelector;\n        }\n        let input = this.el.querySelector(selector);\n        if (!input) {\n            input = this.el.querySelector('input, select, textarea');\n        }\n        if (!input) {\n            console.error('Input not found');\n            return undefined;\n        }\n        return this.$input = input;\n    }\n    init() {\n        this.selectInput();\n        this.bindEvents();\n        this.prepareWrapper();\n        if (this.isInputOptions) {\n            const $input = this.$input;\n            $input.validationMessage = '';\n            $input.setCustomValidity = (msg) => {\n                $input.validationMessage = String(msg);\n            };\n            $input.checkValidity = () => {\n                return this.checkInputOptionsValidity();\n            };\n        }\n    }\n    bindEvents() {\n        if (!this.$input) {\n            return;\n        }\n        this.$input.addEventListener('invalid', (e) => {\n            this.showInvalidResponse();\n        });\n        const events = this.options.events;\n        events.forEach((eventName) => {\n            this.$input?.addEventListener(eventName, () => {\n                this.checkValidity();\n            });\n        });\n    }\n    prepareWrapper() {\n        if (this.el.querySelector(this.errorSelector)?.classList?.contains('invalid-tooltip')) {\n            if (window.getComputedStyle(this.el).position === 'static') {\n                this.el.style.position = 'relative';\n            }\n        }\n    }\n    checkValidity() {\n        if (!this.$input) {\n            return true;\n        }\n        if (this.$input.hasAttribute('readonly')) {\n            return true;\n        }\n        if (this.$input.hasAttribute('[data-novalidate]')) {\n            return true;\n        }\n        if (this.$input.closest('[data-novalidate]')) {\n            return true;\n        }\n        this.$input.setCustomValidity('');\n        let valid = this.$input.checkValidity();\n        if (valid && this.$form) {\n            valid = this.runCustomValidity();\n        }\n        // Raise invalid event\n        // this.$input.checkValidity();\n        this.updateValidClass(valid);\n        return valid;\n    }\n    runCustomValidity() {\n        if (!this.$input) {\n            return true;\n        }\n        // Check custom validity\n        const validates = (this.$input.getAttribute('data-validate') || '').split('|');\n        let result = true;\n        if (this.$input.value !== '' && validates.length) {\n            if (!this.checkCustomDataAttributeValidity()) {\n                return false;\n            }\n            for (const validatorName of validates) {\n                const [validator, options] = this.getValidator(validatorName) || [null, {}];\n                if (!validator) {\n                    continue;\n                }\n                Object.assign(options, validator.options);\n                let r = validator.handler(this.$input.value, this.$input, options, this);\n                // If return is a promise, push to stack and resolve later\n                if (r instanceof Promise || (typeof r === 'object' && r.then)) {\n                    r.then((result) => {\n                        this.handleAsyncCustomResult(result, validator);\n                    });\n                    continue;\n                }\n                if (!this.handleCustomResult(r, validator)) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    async checkValidityAsync() {\n        if (!this.$input) {\n            return true;\n        }\n        if (this.$input.hasAttribute('readonly')) {\n            return true;\n        }\n        this.$input.setCustomValidity('');\n        let valid = this.$input.checkValidity();\n        if (valid && this.$form) {\n            valid = await this.runCustomValidityAsync();\n        }\n        this.updateValidClass(valid);\n        return valid;\n    }\n    async runCustomValidityAsync() {\n        if (!this.$input) {\n            return true;\n        }\n        // Check custom validity\n        const validates = (this.$input.getAttribute('data-validate') || '').split('|');\n        const results = [];\n        const promises = [];\n        if (this.$input.value !== '' && validates.length) {\n            if (!this.checkCustomDataAttributeValidity()) {\n                return false;\n            }\n            for (const validatorName of validates) {\n                let [validator, options] = this.getValidator(validatorName) || [null, {}];\n                if (!validator) {\n                    continue;\n                }\n                options = Object.assign({}, options, validator.options || {});\n                promises.push(Promise.resolve(validator.handler(this.$input.value, this.$input, options, this))\n                    .then((r) => {\n                    results.push(this.handleAsyncCustomResult(r, validator));\n                    return r;\n                }));\n            }\n        }\n        await Promise.all(promises);\n        for (const result of results) {\n            if (result === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    checkCustomDataAttributeValidity() {\n        const error = this.$input?.dataset.validationFail;\n        return this.handleCustomResult(error);\n    }\n    checkInputOptionsValidity() {\n        if (!this.$input) {\n            return true;\n        }\n        const isRequired = this.$input.getAttribute('required') != null;\n        const optionWrappers = this.$input.querySelectorAll(this.options.inputOptionsSelector);\n        let result = true;\n        if (isRequired) {\n            for (const optionWrapper of optionWrappers) {\n                const input = optionWrapper.querySelector('input');\n                result = false;\n                // Only need one checked\n                if (input?.checked) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        // Get browser input validation message\n        const n = document.createElement('input');\n        n.required = isRequired;\n        if (result) {\n            n.value = 'placeholder';\n        }\n        n.checkValidity();\n        this.$input.validationMessage = n.validationMessage;\n        this.$input.validity = n.validity;\n        for (const optionWrapper of optionWrappers) {\n            const input = optionWrapper.querySelector('input');\n            input?.setCustomValidity(n.validationMessage);\n        }\n        if (!result) {\n            this.$input.dispatchEvent(new CustomEvent('invalid'));\n        }\n        return result;\n    }\n    /**\n     * @param valid {boolean}\n     */\n    updateValidClass(valid) {\n        this.$input?.classList.remove(this.invalidClass);\n        this.$input?.classList.remove(this.validClass);\n        this.el.classList.remove(this.invalidClass);\n        this.el.classList.remove(this.validClass);\n        if (valid) {\n            this.$input?.classList.add(this.validClass);\n            this.el.classList.add(this.validClass);\n        }\n        else {\n            this.$input?.classList.add(this.invalidClass);\n            this.el.classList.add(this.invalidClass);\n        }\n    }\n    getFormValidation(element) {\n        return this.$helper.getBoundedInstance(element || this.getForm(), 'form.validation');\n    }\n    getValidator(name) {\n        const matches = name.match(/(?<type>[\\w\\-_]+)(\\((?<params>.*)\\))*/);\n        if (!matches) {\n            return null;\n        }\n        const validatorName = matches.groups?.type || '';\n        const params = matches.groups?.params || '';\n        const fv = this.getFormValidation(this.$form);\n        const validator = fv?.validators[validatorName] || UnicornFormValidation.globalValidators[validatorName];\n        if (!validator) {\n            return null;\n        }\n        const paramMatches = params.matchAll(/(?<key>\\w+)(\\s?[=:]\\s?(?<value>\\w+))?/g);\n        const options = {};\n        for (const paramMatch of paramMatches) {\n            const match = paramMatch?.groups;\n            if (!match) {\n                continue;\n            }\n            options[match.key] = handleParamValue(match.value);\n        }\n        return [validator, options];\n    }\n    handleCustomResult(result, validator) {\n        if (typeof result === 'string') {\n            this.$input?.setCustomValidity(result);\n            result = result === '';\n        }\n        else if (result === undefined) {\n            result = true;\n        }\n        if (result) {\n            this.$input?.setCustomValidity('');\n        }\n        else if (validator) {\n            this.raiseCustomErrorState(validator);\n        }\n        return result;\n    }\n    handleAsyncCustomResult(result, validator) {\n        result = this.handleCustomResult(result, validator);\n        // Fire invalid events\n        this.$input?.checkValidity();\n        this.updateValidClass(result);\n        return result;\n    }\n    raiseCustomErrorState(validator) {\n        let help;\n        if (this.$input?.validationMessage === '') {\n            help = validator.options?.notice;\n            if (typeof help === 'function') {\n                help = help(this.$input, this);\n            }\n            if (help != null) {\n                this.$input?.setCustomValidity(help);\n            }\n        }\n        if (this.$input?.validationMessage === '') {\n            this.$input?.setCustomValidity(this.$lang.__('unicorn.message.validation.custom.error'));\n        }\n        this.$input?.dispatchEvent(new CustomEvent('invalid'));\n    }\n    setAsInvalidAndReport(error) {\n        this.setCustomValidity(error);\n        this.showInvalidResponse();\n    }\n    setCustomValidity(error) {\n        this.$input?.setCustomValidity(error);\n    }\n    reportValidity() {\n        if (this.validationMessage !== '') {\n            this.showInvalidResponse();\n        }\n    }\n    showInvalidResponse() {\n        this.updateValidClass(false);\n        /** @type ValidityState */\n        const state = this.$input?.validity;\n        let message = this.$input?.validationMessage || '';\n        for (let key in state) {\n            if (state[key] && this.$input?.dataset[key + 'Message']) {\n                message = this.$input?.dataset[key + 'Message'] || '';\n                break;\n            }\n        }\n        if (!this.isVisible) {\n            let title = this.findLabel()?.textContent;\n            if (!title) {\n                title = this.$input?.name || '';\n            }\n            this.$ui.renderMessage(`Field: ${title} - ${message}`, 'warning');\n        }\n        let $help = this.el.querySelector(this.errorSelector);\n        if (!$help) {\n            $help = this.createHelpElement();\n            this.el.appendChild($help);\n            this.prepareWrapper();\n        }\n        $help.textContent = message;\n    }\n    createHelpElement() {\n        const className = this.options.errorMessageClass;\n        const parsed = this.parseSelector(this.errorSelector || '');\n        const $help = this.$helper.html(`<div class=\"${className}\"></div>`);\n        $help.classList.add(...parsed.classes);\n        parsed.attrs.forEach((attr) => {\n            $help.setAttribute(attr[0], attr[1] || '');\n        });\n        parsed.ids.forEach((id) => {\n            $help.id = id;\n        });\n        return $help;\n    }\n    /**\n     * @see https://stackoverflow.com/a/17888178\n     */\n    parseSelector(subselector) {\n        const obj = { tags: [], classes: [], ids: [], attrs: [] };\n        for (const token of subselector.split(/(?=\\.)|(?=#)|(?=\\[)/)) {\n            switch (token[0]) {\n                case '#':\n                    obj.ids.push(token.slice(1));\n                    break;\n                case '.':\n                    obj.classes.push(token.slice(1));\n                    break;\n                case '[':\n                    obj.attrs.push(token.slice(1, -1).split('='));\n                    break;\n                default:\n                    obj.tags.push(token);\n                    break;\n            }\n        }\n        return obj;\n    }\n    setAsValidAndClearResponse() {\n        this.setCustomValidity('');\n        this.updateValidClass(true);\n        this.clearInvalidResponse();\n    }\n    clearInvalidResponse() {\n        const $help = this.el.querySelector(this.errorSelector);\n        $help.textContent = '';\n    }\n    getForm() {\n        return this.el.closest(this.options.formSelector || '[uni-form-validate]');\n    }\n    findLabel() {\n        const id = this.$input?.id || '';\n        const wrapper = this.$input?.closest('[data-field-wrapper]');\n        let label = null;\n        if (wrapper) {\n            label = wrapper.querySelector('[data-field-label]');\n        }\n        if (!label) {\n            label = document.querySelector(`label[for=\"${id}\"]`);\n        }\n        return label;\n    }\n}\nfunction camelTo(str, sep) {\n    return str.replace(/([a-z])([A-Z])/g, `$1${sep}$2`).toLowerCase();\n}\nvalidatorHandlers.username = function (value, element) {\n    const regex = new RegExp('[\\<|\\>|\"|\\'|\\%|\\;|\\(|\\)|\\&]', 'i');\n    return !regex.test(value);\n};\nvalidatorHandlers.numeric = function (value, element) {\n    const regex = /^(\\d|-)?(\\d|,)*\\.?\\d*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.email = function (value, element) {\n    value = punycode__WEBPACK_IMPORTED_MODULE_0__.toASCII(value);\n    const regex = /^[a-zA-Z0-9.!#$%&*+\\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.url = function (value, element) {\n    const regex = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i;\n    return regex.test(value);\n};\nvalidatorHandlers.alnum = function (value, element) {\n    const regex = /^[a-zA-Z0-9]*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.color = function (value, element) {\n    const regex = /^#(?:[0-9a-f]{3}){1,2}$/;\n    return regex.test(value);\n};\n/**\n * @see  http://www.virtuosimedia.com/dev/php/37-tested-php-perl-and-javascript-regular-expressions\n */\nvalidatorHandlers.creditcard = function (value, element) {\n    const regex = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6011[0-9]{12}|622((12[6-9]|1[3-9][0-9])|([2-8][0-9][0-9])|(9(([0-1][0-9])|(2[0-5]))))[0-9]{10}|64[4-9][0-9]{13}|65[0-9]{14}|3(?:0[0-5]|[68][0-9])[0-9]{11}|3[47][0-9]{13})*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.ip = function (value, element) {\n    const regex = /^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$/;\n    return regex.test(value);\n};\nvalidatorHandlers['password-confirm'] = function (value, element) {\n    const selector = element.dataset.confirmTarget;\n    if (!selector) {\n        throw new Error('Validator: \"password-confirm\" must add \"data-confirm-target\" attribute.');\n    }\n    const target = document.querySelector(selector);\n    return target?.value === value;\n};\n\n// customElements.define(UnicornFormValidateElement.is, UnicornFormValidateElement);\n// customElements.define(UnicornFieldValidateElement.is, UnicornFieldValidateElement);\nfunction initValidations(app) {\n    const directive = app.inject('$directive');\n    const helper = app.inject('$helper');\n    directive.register('form-validate', {\n        mounted(el, binding) {\n            helper.getBoundedInstance(el, 'form.validation', (ele) => {\n                return new UnicornFormValidation(app, ele, JSON.parse(binding.value || '{}'));\n            });\n        },\n        updated(el, binding) {\n            const instance = helper.getBoundedInstance(el, 'form.validation');\n            instance.setOptions(JSON.parse(binding.value || '{}'));\n        }\n    });\n    directive.register('field-validate', {\n        mounted(el, binding) {\n            helper.getBoundedInstance(el, 'field.validation', (ele) => {\n                return new UnicornFieldValidation(app, ele, JSON.parse(binding.value || '{}'));\n            });\n        },\n        updated(el, binding) {\n            const instance = helper.getBoundedInstance(el, 'field.validation');\n            instance?.setOptions(JSON.parse(binding.value || '{}') || {});\n        }\n    });\n}\nfunction handleParamValue(value) {\n    if (!isNaN(Number(value))) {\n        return Number(value);\n    }\n    if (value === 'null') {\n        return null;\n    }\n    if (value === 'true') {\n        return true;\n    }\n    if (value === 'false') {\n        return true;\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy91aS92YWxpZGF0aW9uLWNvbXBvbmVudHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy4vc3JjL21vZHVsZXMvdWkvdmFsaWRhdGlvbi1jb21wb25lbnRzLnRzLy4vc3JjL21vZHVsZXMvdWkvdmFsaWRhdGlvbi1jb21wb25lbnRzLnRzPzAxNDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcHVueWNvZGUgZnJvbSAncHVueWNvZGUnO1xuY29uc3QgdmFsaWRhdG9ySGFuZGxlcnMgPSB7fTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHNjcm9sbDogZmFsc2UsXG4gICAgc2Nyb2xsT2Zmc2V0OiAtMTAwLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZmllbGRTZWxlY3RvcjogbnVsbCxcbiAgICB2YWxpZGF0ZWRDbGFzczogbnVsbCxcbn07XG5jb25zdCBkZWZhdWx0RmllbGRPcHRpb25zID0ge1xuICAgIGZvcm1TZWxlY3RvcjogJ1t1bmktZm9ybS12YWxpZGF0ZV0nLFxuICAgIGVycm9yU2VsZWN0b3I6ICdbZGF0YS1maWVsZC1lcnJvcl0nLFxuICAgIHNlbGVjdG9yOiAnaW5wdXRbZGF0YS1maWVsZC1pbnB1dF0sIHNlbGVjdFtkYXRhLWZpZWxkLWlucHV0XSwgdGV4dGFyZWFbZGF0YS1maWVsZC1pbnB1dF0nLFxuICAgIHZhbGlkQ2xhc3M6ICdpcy12YWxpZCcsXG4gICAgaW52YWxpZENsYXNzOiAnaXMtaW52YWxpZCcsXG4gICAgZXZlbnRzOiBbJ2NoYW5nZSddLFxuICAgIGVycm9yTWVzc2FnZUNsYXNzOiAnaW52YWxpZC10b29sdGlwJyxcbiAgICBpbnB1dE9wdGlvbnM6IGZhbHNlLFxuICAgIGlucHV0T3B0aW9uc1dyYXBwZXJTZWxlY3RvcjogJ2RpdltkYXRhLWZpZWxkLWlucHV0XScsXG4gICAgaW5wdXRPcHRpb25zU2VsZWN0b3I6ICdbZGF0YS1pbnB1dC1vcHRpb25dJ1xufTtcbmV4cG9ydCBjbGFzcyBVbmljb3JuRm9ybVZhbGlkYXRpb24ge1xuICAgIGFwcDtcbiAgICBwcmVzZXRGaWVsZHMgPSBbXTtcbiAgICBzdGF0aWMgZ2xvYmFsVmFsaWRhdG9ycyA9IHt9O1xuICAgIHZhbGlkYXRvcnMgPSB7fTtcbiAgICBvcHRpb25zO1xuICAgICRmb3JtO1xuICAgIHN0YXRpYyBpcyA9ICd1bmktZm9ybS12YWxpZGF0ZSc7XG4gICAgY29uc3RydWN0b3IoYXBwLCBlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLiRmb3JtID0gdGhpcy4kaGVscGVyLnNlbGVjdE9uZShlbCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuJGhlbHBlci5kZWZhdWx0c0RlZXAoe30sIG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRlZmF1bHRWYWxpZGF0b3JzKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBnZXQgJGhlbHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmluamVjdCgnJGhlbHBlcicpO1xuICAgIH1cbiAgICBnZXQgJHVpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAuaW5qZWN0KCckdWknKTtcbiAgICB9XG4gICAgZ2V0ICRsYW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAuaW5qZWN0KCckbGFuZycpO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy4kaGVscGVyLmRlZmF1bHRzRGVlcCh7fSwgb3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zY3JvbGw7XG4gICAgfVxuICAgIGdldCBzY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5vcHRpb25zLnNjcm9sbE9mZnNldCB8fCAtMTAwKTtcbiAgICB9XG4gICAgZ2V0IGZpZWxkU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmllbGRTZWxlY3RvciB8fCAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnO1xuICAgIH1cbiAgICBnZXQgdmFsaWRhdGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsaWRhdGVkQ2xhc3MgfHwgJ3dhcy12YWxpZGF0ZWQnO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAodGhpcy4kZm9ybS50YWdOYW1lID09PSAnRk9STScpIHtcbiAgICAgICAgICAgIHRoaXMuJGZvcm0uc2V0QXR0cmlidXRlKCdub3ZhbGlkYXRlJywgJ3RydWUnKTtcbiAgICAgICAgICAgIHRoaXMuJGZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVkICYmICF0aGlzLnZhbGlkYXRlQWxsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7IC8vIFN0b3AgZm9sbG93aW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaW52YWxpZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXBhcmVGaWVsZHModGhpcy5maW5kRE9NRmllbGRzKCkpO1xuICAgICAgICB0aGlzLnByZXBhcmVGaWVsZHModGhpcy5wcmVzZXRGaWVsZHMpO1xuICAgIH1cbiAgICBmaW5kRE9NRmllbGRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaGVscGVyLnNlbGVjdEFsbCh0aGlzLiRmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5maWVsZFNlbGVjdG9yKSk7XG4gICAgfVxuICAgIHByZXBhcmVGaWVsZHMoaW5wdXRzKSB7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlRmllbGRXcmFwcGVyKGlucHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhaXQgbmV4dCB0aWNrXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcHJlcGFyZUZpZWxkV3JhcHBlcihpbnB1dCkge1xuICAgICAgICBpZiAoWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXS5pbmRleE9mKGlucHV0LnRhZ05hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSBpbnB1dC5jbG9zZXN0KCdbdW5pLWZpZWxkLXZhbGlkYXRlXScpO1xuICAgICAgICAgICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IGlucHV0LmNsb3Nlc3QoJ1tkYXRhLWlucHV0LWNvbnRhaW5lcl0nKSB8fCBpbnB1dC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIHdyYXBwZXI/LnNldEF0dHJpYnV0ZSgndW5pLWZpZWxkLXZhbGlkYXRlJywgJ3t9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGZpbmRGaWVsZHMoY29udGFpbnNQcmVzZXRzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgaW5wdXRzID0gdGhpcy5maW5kRE9NRmllbGRzKCk7XG4gICAgICAgIGlmIChjb250YWluc1ByZXNldHMpIHtcbiAgICAgICAgICAgIGlucHV0cy5wdXNoKC4uLnRoaXMucHJlc2V0RmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRzLm1hcCgoaW5wdXQpID0+IHRoaXMucHJlcGFyZUZpZWxkV3JhcHBlcihpbnB1dCkpXG4gICAgICAgICAgICAuZmlsdGVyKGlucHV0ID0+IGlucHV0ICE9IG51bGwpO1xuICAgIH1cbiAgICBnZXRGaWVsZENvbXBvbmVudChpbnB1dCkge1xuICAgICAgICBsZXQgdiA9IHRoaXMuJGhlbHBlci5nZXRCb3VuZGVkSW5zdGFuY2UoaW5wdXQsICdmaWVsZC52YWxpZGF0aW9uJyk7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IGlucHV0LmNsb3Nlc3QoJ1t1bmktZmllbGQtdmFsaWRhdGVdJyk7XG4gICAgICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgICAgICAgIHYgPSB0aGlzLiRoZWxwZXIuZ2V0Qm91bmRlZEluc3RhbmNlKHdyYXBwZXIsICdmaWVsZC52YWxpZGF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHZhbGlkYXRlQWxsKGZpZWxkcykge1xuICAgICAgICB0aGlzLm1hcmtGb3JtQXNVbnZhbGlkYXRlZCgpO1xuICAgICAgICBmaWVsZHMgPSBmaWVsZHMgfHwgdGhpcy5maW5kRmllbGRzKCk7XG4gICAgICAgIGxldCBmaXJzdEZhaWwgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZnYgPSB0aGlzLmdldEZpZWxkQ29tcG9uZW50KGZpZWxkKTtcbiAgICAgICAgICAgIGlmICghZnYpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZ2LmNoZWNrVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmICFmaXJzdEZhaWwpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEZhaWwgPSBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtGb3JtQXNWYWxpZGF0ZWQoKTtcbiAgICAgICAgaWYgKGZpcnN0RmFpbCAmJiB0aGlzLnNjcm9sbEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8oZmlyc3RGYWlsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3RGYWlsID09PSBudWxsO1xuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZUFsbEFzeW5jKGZpZWxkcykge1xuICAgICAgICB0aGlzLm1hcmtGb3JtQXNVbnZhbGlkYXRlZCgpO1xuICAgICAgICBmaWVsZHMgPSBmaWVsZHMgfHwgdGhpcy5maW5kRmllbGRzKCk7XG4gICAgICAgIGxldCBmaXJzdEZhaWwgPSBudWxsO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgZnYgPSB0aGlzLmdldEZpZWxkQ29tcG9uZW50KGZpZWxkKTtcbiAgICAgICAgICAgIGlmICghZnYpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZnYuY2hlY2tWYWxpZGl0eUFzeW5jKCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgIWZpcnN0RmFpbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEZhaWwgPSBmaWVsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHRoaXMubWFya0Zvcm1Bc1ZhbGlkYXRlZCgpO1xuICAgICAgICBpZiAoZmlyc3RGYWlsICYmIHRoaXMuc2Nyb2xsRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyhmaXJzdEZhaWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdEZhaWwgPT09IG51bGw7XG4gICAgfVxuICAgIHNjcm9sbFRvKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5zY3JvbGxPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NpdGlvbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICBjb25zdCBvZmZzZXRQb3NpdGlvbiA9IGVsZW1lbnRQb3NpdGlvbiArIHdpbmRvdy5zY3JvbGxZICsgb2Zmc2V0O1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgdG9wOiBvZmZzZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFya0Zvcm1Bc1ZhbGlkYXRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZm9ybS5jbGFzc0xpc3QuYWRkKHRoaXMudmFsaWRhdGVkQ2xhc3MpO1xuICAgIH1cbiAgICBtYXJrRm9ybUFzVW52YWxpZGF0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGZvcm0uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnZhbGlkYXRlZENsYXNzKTtcbiAgICB9XG4gICAgYWRkRmllbGQoZmllbGQpIHtcbiAgICAgICAgdGhpcy5wcmVzZXRGaWVsZHMucHVzaChmaWVsZCk7XG4gICAgICAgIHRoaXMucHJlcGFyZUZpZWxkV3JhcHBlcihmaWVsZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWdpc3RlckRlZmF1bHRWYWxpZGF0b3JzKCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHZhbGlkYXRvckhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFZhbGlkYXRvcihuYW1lLCB2YWxpZGF0b3JIYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHZhbGlkYXRvciBoYW5kbGVyLlxuICAgICAqL1xuICAgIGFkZFZhbGlkYXRvcihuYW1lLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMudmFsaWRhdG9yc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdmFsaWRhdG9yIGhhbmRsZXIuXG4gICAgICovXG4gICAgc3RhdGljIGFkZEdsb2JhbFZhbGlkYXRvcihuYW1lLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuZ2xvYmFsVmFsaWRhdG9yc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVbmljb3JuRmllbGRWYWxpZGF0aW9uIHtcbiAgICBhcHA7XG4gICAgZWw7XG4gICAgJGlucHV0O1xuICAgIG9wdGlvbnM7XG4gICAgc3RhdGljIGlzID0gJ3VuaS1maWVsZC12YWxpZGF0ZSc7XG4gICAgY29uc3RydWN0b3IoYXBwLCBlbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuJGhlbHBlci5kZWZhdWx0c0RlZXAoe30sIG9wdGlvbnMsIGRlZmF1bHRGaWVsZE9wdGlvbnMpO1xuICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuc2VsZWN0SW5wdXQoKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIGdldCAkaGVscGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAuaW5qZWN0KCckaGVscGVyJyk7XG4gICAgfVxuICAgIGdldCAkbGFuZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmluamVjdCgnJGxhbmcnKTtcbiAgICB9XG4gICAgZ2V0ICR1aSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmluamVjdCgnJHVpJyk7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLiRoZWxwZXIuZGVmYXVsdHNEZWVwKHt9LCBvcHRpb25zLCBkZWZhdWx0RmllbGRPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0ICRmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCk7XG4gICAgfVxuICAgIGdldCBlcnJvclNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmVycm9yU2VsZWN0b3I7XG4gICAgfVxuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zZWxlY3RvcjtcbiAgICB9XG4gICAgZ2V0IHZhbGlkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmFsaWRDbGFzcztcbiAgICB9XG4gICAgZ2V0IGludmFsaWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pbnZhbGlkQ2xhc3M7XG4gICAgfVxuICAgIGdldCBpc1Zpc2libGUoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmVsLm9mZnNldFdpZHRoIHx8IHRoaXMuZWwub2Zmc2V0SGVpZ2h0IHx8IHRoaXMuZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgaXNJbnB1dE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMub3B0aW9ucy5pbnB1dE9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgdmFsaWRhdGlvbk1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpbnB1dD8udmFsaWRhdGlvbk1lc3NhZ2UgfHwgJyc7XG4gICAgfVxuICAgIGdldCB2YWxpZGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0Py52YWxpZGl0eTtcbiAgICB9XG4gICAgc2VsZWN0SW5wdXQoKSB7XG4gICAgICAgIGxldCBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5wdXRPcHRpb25zKSB7XG4gICAgICAgICAgICBzZWxlY3RvciArPSAnLCAnICsgdGhpcy5vcHRpb25zLmlucHV0T3B0aW9uc1dyYXBwZXJTZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5wdXQgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICBpbnB1dCA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnB1dCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0ID0gaW5wdXQ7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgICAgIHRoaXMucHJlcGFyZVdyYXBwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9IHRoaXMuJGlucHV0O1xuICAgICAgICAgICAgJGlucHV0LnZhbGlkYXRpb25NZXNzYWdlID0gJyc7XG4gICAgICAgICAgICAkaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgJGlucHV0LnZhbGlkYXRpb25NZXNzYWdlID0gU3RyaW5nKG1zZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJGlucHV0LmNoZWNrVmFsaWRpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dE9wdGlvbnNWYWxpZGl0eSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW52YWxpZCcsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNob3dJbnZhbGlkUmVzcG9uc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMub3B0aW9ucy5ldmVudHM7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Py5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcmVwYXJlV3JhcHBlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwucXVlcnlTZWxlY3Rvcih0aGlzLmVycm9yU2VsZWN0b3IpPy5jbGFzc0xpc3Q/LmNvbnRhaW5zKCdpbnZhbGlkLXRvb2x0aXAnKSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrVmFsaWRpdHkoKSB7XG4gICAgICAgIGlmICghdGhpcy4kaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRpbnB1dC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRpbnB1dC5oYXNBdHRyaWJ1dGUoJ1tkYXRhLW5vdmFsaWRhdGVdJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiRpbnB1dC5jbG9zZXN0KCdbZGF0YS1ub3ZhbGlkYXRlXScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRpbnB1dC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgICAgIGxldCB2YWxpZCA9IHRoaXMuJGlucHV0LmNoZWNrVmFsaWRpdHkoKTtcbiAgICAgICAgaWYgKHZhbGlkICYmIHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgIHZhbGlkID0gdGhpcy5ydW5DdXN0b21WYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJhaXNlIGludmFsaWQgZXZlbnRcbiAgICAgICAgLy8gdGhpcy4kaW5wdXQuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkQ2xhc3ModmFsaWQpO1xuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIHJ1bkN1c3RvbVZhbGlkaXR5KCkge1xuICAgICAgICBpZiAoIXRoaXMuJGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBjdXN0b20gdmFsaWRpdHlcbiAgICAgICAgY29uc3QgdmFsaWRhdGVzID0gKHRoaXMuJGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWxpZGF0ZScpIHx8ICcnKS5zcGxpdCgnfCcpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuJGlucHV0LnZhbHVlICE9PSAnJyAmJiB2YWxpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tDdXN0b21EYXRhQXR0cmlidXRlVmFsaWRpdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsaWRhdG9yTmFtZSBvZiB2YWxpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbdmFsaWRhdG9yLCBvcHRpb25zXSA9IHRoaXMuZ2V0VmFsaWRhdG9yKHZhbGlkYXRvck5hbWUpIHx8IFtudWxsLCB7fV07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdmFsaWRhdG9yLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGxldCByID0gdmFsaWRhdG9yLmhhbmRsZXIodGhpcy4kaW5wdXQudmFsdWUsIHRoaXMuJGlucHV0LCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBJZiByZXR1cm4gaXMgYSBwcm9taXNlLCBwdXNoIHRvIHN0YWNrIGFuZCByZXNvbHZlIGxhdGVyXG4gICAgICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlIHx8ICh0eXBlb2YgciA9PT0gJ29iamVjdCcgJiYgci50aGVuKSkge1xuICAgICAgICAgICAgICAgICAgICByLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBc3luY0N1c3RvbVJlc3VsdChyZXN1bHQsIHZhbGlkYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhbmRsZUN1c3RvbVJlc3VsdChyLCB2YWxpZGF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tWYWxpZGl0eUFzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kaW5wdXQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRpbnB1dC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgICAgIGxldCB2YWxpZCA9IHRoaXMuJGlucHV0LmNoZWNrVmFsaWRpdHkoKTtcbiAgICAgICAgaWYgKHZhbGlkICYmIHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgIHZhbGlkID0gYXdhaXQgdGhpcy5ydW5DdXN0b21WYWxpZGl0eUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZENsYXNzKHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBhc3luYyBydW5DdXN0b21WYWxpZGl0eUFzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBjdXN0b20gdmFsaWRpdHlcbiAgICAgICAgY29uc3QgdmFsaWRhdGVzID0gKHRoaXMuJGlucHV0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWxpZGF0ZScpIHx8ICcnKS5zcGxpdCgnfCcpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLiRpbnB1dC52YWx1ZSAhPT0gJycgJiYgdmFsaWRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ3VzdG9tRGF0YUF0dHJpYnV0ZVZhbGlkaXR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkYXRvck5hbWUgb2YgdmFsaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IFt2YWxpZGF0b3IsIG9wdGlvbnNdID0gdGhpcy5nZXRWYWxpZGF0b3IodmFsaWRhdG9yTmFtZSkgfHwgW251bGwsIHt9XTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHZhbGlkYXRvci5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFByb21pc2UucmVzb2x2ZSh2YWxpZGF0b3IuaGFuZGxlcih0aGlzLiRpbnB1dC52YWx1ZSwgdGhpcy4kaW5wdXQsIG9wdGlvbnMsIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5oYW5kbGVBc3luY0N1c3RvbVJlc3VsdChyLCB2YWxpZGF0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNoZWNrQ3VzdG9tRGF0YUF0dHJpYnV0ZVZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuJGlucHV0Py5kYXRhc2V0LnZhbGlkYXRpb25GYWlsO1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDdXN0b21SZXN1bHQoZXJyb3IpO1xuICAgIH1cbiAgICBjaGVja0lucHV0T3B0aW9uc1ZhbGlkaXR5KCkge1xuICAgICAgICBpZiAoIXRoaXMuJGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1JlcXVpcmVkID0gdGhpcy4kaW5wdXQuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpICE9IG51bGw7XG4gICAgICAgIGNvbnN0IG9wdGlvbldyYXBwZXJzID0gdGhpcy4kaW5wdXQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuaW5wdXRPcHRpb25zU2VsZWN0b3IpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uV3JhcHBlciBvZiBvcHRpb25XcmFwcGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gb3B0aW9uV3JhcHBlci5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgbmVlZCBvbmUgY2hlY2tlZFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dD8uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGJyb3dzZXIgaW5wdXQgdmFsaWRhdGlvbiBtZXNzYWdlXG4gICAgICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBuLnJlcXVpcmVkID0gaXNSZXF1aXJlZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgbi52YWx1ZSA9ICdwbGFjZWhvbGRlcic7XG4gICAgICAgIH1cbiAgICAgICAgbi5jaGVja1ZhbGlkaXR5KCk7XG4gICAgICAgIHRoaXMuJGlucHV0LnZhbGlkYXRpb25NZXNzYWdlID0gbi52YWxpZGF0aW9uTWVzc2FnZTtcbiAgICAgICAgdGhpcy4kaW5wdXQudmFsaWRpdHkgPSBuLnZhbGlkaXR5O1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbldyYXBwZXIgb2Ygb3B0aW9uV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gb3B0aW9uV3JhcHBlci5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXQ/LnNldEN1c3RvbVZhbGlkaXR5KG4udmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaW52YWxpZCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsaWQge2Jvb2xlYW59XG4gICAgICovXG4gICAgdXBkYXRlVmFsaWRDbGFzcyh2YWxpZCkge1xuICAgICAgICB0aGlzLiRpbnB1dD8uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmludmFsaWRDbGFzcyk7XG4gICAgICAgIHRoaXMuJGlucHV0Py5jbGFzc0xpc3QucmVtb3ZlKHRoaXMudmFsaWRDbGFzcyk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmludmFsaWRDbGFzcyk7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnZhbGlkQ2xhc3MpO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Py5jbGFzc0xpc3QuYWRkKHRoaXMudmFsaWRDbGFzcyk7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy52YWxpZENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Py5jbGFzc0xpc3QuYWRkKHRoaXMuaW52YWxpZENsYXNzKTtcbiAgICAgICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmludmFsaWRDbGFzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Rm9ybVZhbGlkYXRpb24oZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaGVscGVyLmdldEJvdW5kZWRJbnN0YW5jZShlbGVtZW50IHx8IHRoaXMuZ2V0Rm9ybSgpLCAnZm9ybS52YWxpZGF0aW9uJyk7XG4gICAgfVxuICAgIGdldFZhbGlkYXRvcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBuYW1lLm1hdGNoKC8oPzx0eXBlPltcXHdcXC1fXSspKFxcKCg/PHBhcmFtcz4uKilcXCkpKi8pO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvck5hbWUgPSBtYXRjaGVzLmdyb3Vwcz8udHlwZSB8fCAnJztcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hlcy5ncm91cHM/LnBhcmFtcyB8fCAnJztcbiAgICAgICAgY29uc3QgZnYgPSB0aGlzLmdldEZvcm1WYWxpZGF0aW9uKHRoaXMuJGZvcm0pO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBmdj8udmFsaWRhdG9yc1t2YWxpZGF0b3JOYW1lXSB8fCBVbmljb3JuRm9ybVZhbGlkYXRpb24uZ2xvYmFsVmFsaWRhdG9yc1t2YWxpZGF0b3JOYW1lXTtcbiAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtTWF0Y2hlcyA9IHBhcmFtcy5tYXRjaEFsbCgvKD88a2V5PlxcdyspKFxccz9bPTpdXFxzPyg/PHZhbHVlPlxcdyspKT8vZyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbU1hdGNoIG9mIHBhcmFtTWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXJhbU1hdGNoPy5ncm91cHM7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zW21hdGNoLmtleV0gPSBoYW5kbGVQYXJhbVZhbHVlKG1hdGNoLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ZhbGlkYXRvciwgb3B0aW9uc107XG4gICAgfVxuICAgIGhhbmRsZUN1c3RvbVJlc3VsdChyZXN1bHQsIHZhbGlkYXRvcikge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Py5zZXRDdXN0b21WYWxpZGl0eShyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dD8uc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZUN1c3RvbUVycm9yU3RhdGUodmFsaWRhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoYW5kbGVBc3luY0N1c3RvbVJlc3VsdChyZXN1bHQsIHZhbGlkYXRvcikge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZUN1c3RvbVJlc3VsdChyZXN1bHQsIHZhbGlkYXRvcik7XG4gICAgICAgIC8vIEZpcmUgaW52YWxpZCBldmVudHNcbiAgICAgICAgdGhpcy4kaW5wdXQ/LmNoZWNrVmFsaWRpdHkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZENsYXNzKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJhaXNlQ3VzdG9tRXJyb3JTdGF0ZSh2YWxpZGF0b3IpIHtcbiAgICAgICAgbGV0IGhlbHA7XG4gICAgICAgIGlmICh0aGlzLiRpbnB1dD8udmFsaWRhdGlvbk1lc3NhZ2UgPT09ICcnKSB7XG4gICAgICAgICAgICBoZWxwID0gdmFsaWRhdG9yLm9wdGlvbnM/Lm5vdGljZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGVscCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhlbHAgPSBoZWxwKHRoaXMuJGlucHV0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWxwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dD8uc2V0Q3VzdG9tVmFsaWRpdHkoaGVscCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGlucHV0Py52YWxpZGF0aW9uTWVzc2FnZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Py5zZXRDdXN0b21WYWxpZGl0eSh0aGlzLiRsYW5nLl9fKCd1bmljb3JuLm1lc3NhZ2UudmFsaWRhdGlvbi5jdXN0b20uZXJyb3InKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaW5wdXQ/LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpbnZhbGlkJykpO1xuICAgIH1cbiAgICBzZXRBc0ludmFsaWRBbmRSZXBvcnQoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zZXRDdXN0b21WYWxpZGl0eShlcnJvcik7XG4gICAgICAgIHRoaXMuc2hvd0ludmFsaWRSZXNwb25zZSgpO1xuICAgIH1cbiAgICBzZXRDdXN0b21WYWxpZGl0eShlcnJvcikge1xuICAgICAgICB0aGlzLiRpbnB1dD8uc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3IpO1xuICAgIH1cbiAgICByZXBvcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGlvbk1lc3NhZ2UgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dJbnZhbGlkUmVzcG9uc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG93SW52YWxpZFJlc3BvbnNlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkQ2xhc3MoZmFsc2UpO1xuICAgICAgICAvKiogQHR5cGUgVmFsaWRpdHlTdGF0ZSAqL1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuJGlucHV0Py52YWxpZGl0eTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLiRpbnB1dD8udmFsaWRhdGlvbk1lc3NhZ2UgfHwgJyc7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gJiYgdGhpcy4kaW5wdXQ/LmRhdGFzZXRba2V5ICsgJ01lc3NhZ2UnXSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLiRpbnB1dD8uZGF0YXNldFtrZXkgKyAnTWVzc2FnZSddIHx8ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIGxldCB0aXRsZSA9IHRoaXMuZmluZExhYmVsKCk/LnRleHRDb250ZW50O1xuICAgICAgICAgICAgaWYgKCF0aXRsZSkge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gdGhpcy4kaW5wdXQ/Lm5hbWUgfHwgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiR1aS5yZW5kZXJNZXNzYWdlKGBGaWVsZDogJHt0aXRsZX0gLSAke21lc3NhZ2V9YCwgJ3dhcm5pbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgJGhlbHAgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IodGhpcy5lcnJvclNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCEkaGVscCkge1xuICAgICAgICAgICAgJGhlbHAgPSB0aGlzLmNyZWF0ZUhlbHBFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKCRoZWxwKTtcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZVdyYXBwZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAkaGVscC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGNyZWF0ZUhlbHBFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlQ2xhc3M7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VTZWxlY3Rvcih0aGlzLmVycm9yU2VsZWN0b3IgfHwgJycpO1xuICAgICAgICBjb25zdCAkaGVscCA9IHRoaXMuJGhlbHBlci5odG1sKGA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWV9XCI+PC9kaXY+YCk7XG4gICAgICAgICRoZWxwLmNsYXNzTGlzdC5hZGQoLi4ucGFyc2VkLmNsYXNzZXMpO1xuICAgICAgICBwYXJzZWQuYXR0cnMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICAgICAgJGhlbHAuc2V0QXR0cmlidXRlKGF0dHJbMF0sIGF0dHJbMV0gfHwgJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyc2VkLmlkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgJGhlbHAuaWQgPSBpZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkaGVscDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc4ODgxNzhcbiAgICAgKi9cbiAgICBwYXJzZVNlbGVjdG9yKHN1YnNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHsgdGFnczogW10sIGNsYXNzZXM6IFtdLCBpZHM6IFtdLCBhdHRyczogW10gfTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBzdWJzZWxlY3Rvci5zcGxpdCgvKD89XFwuKXwoPz0jKXwoPz1cXFspLykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLmlkcy5wdXNoKHRva2VuLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICAgIG9iai5jbGFzc2VzLnB1c2godG9rZW4uc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLmF0dHJzLnB1c2godG9rZW4uc2xpY2UoMSwgLTEpLnNwbGl0KCc9JykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmoudGFncy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgc2V0QXNWYWxpZEFuZENsZWFyUmVzcG9uc2UoKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkQ2xhc3ModHJ1ZSk7XG4gICAgICAgIHRoaXMuY2xlYXJJbnZhbGlkUmVzcG9uc2UoKTtcbiAgICB9XG4gICAgY2xlYXJJbnZhbGlkUmVzcG9uc2UoKSB7XG4gICAgICAgIGNvbnN0ICRoZWxwID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKHRoaXMuZXJyb3JTZWxlY3Rvcik7XG4gICAgICAgICRoZWxwLnRleHRDb250ZW50ID0gJyc7XG4gICAgfVxuICAgIGdldEZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsb3Nlc3QodGhpcy5vcHRpb25zLmZvcm1TZWxlY3RvciB8fCAnW3VuaS1mb3JtLXZhbGlkYXRlXScpO1xuICAgIH1cbiAgICBmaW5kTGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy4kaW5wdXQ/LmlkIHx8ICcnO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gdGhpcy4kaW5wdXQ/LmNsb3Nlc3QoJ1tkYXRhLWZpZWxkLXdyYXBwZXJdJyk7XG4gICAgICAgIGxldCBsYWJlbCA9IG51bGw7XG4gICAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignW2RhdGEtZmllbGQtbGFiZWxdJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgICAgbGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsYWJlbFtmb3I9XCIke2lkfVwiXWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG59XG5mdW5jdGlvbiBjYW1lbFRvKHN0ciwgc2VwKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBgJDEke3NlcH0kMmApLnRvTG93ZXJDYXNlKCk7XG59XG52YWxpZGF0b3JIYW5kbGVycy51c2VybmFtZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCkge1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcPHxcXD58XCJ8XFwnfFxcJXxcXDt8XFwofFxcKXxcXCZdJywgJ2knKTtcbiAgICByZXR1cm4gIXJlZ2V4LnRlc3QodmFsdWUpO1xufTtcbnZhbGlkYXRvckhhbmRsZXJzLm51bWVyaWMgPSBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWdleCA9IC9eKFxcZHwtKT8oXFxkfCwpKlxcLj9cXGQqJC87XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpO1xufTtcbnZhbGlkYXRvckhhbmRsZXJzLmVtYWlsID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgdmFsdWUgPSBwdW55Y29kZS50b0FTQ0lJKHZhbHVlKTtcbiAgICBjb25zdCByZWdleCA9IC9eW2EtekEtWjAtOS4hIyQlJsOi4oKs4oSiKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOS1dKyg/OlxcLlthLXpBLVowLTktXSspKiQvO1xuICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKTtcbn07XG52YWxpZGF0b3JIYW5kbGVycy51cmwgPSBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWdleCA9IC9eKD86KD86aHR0cHM/fGZ0cCk6XFwvXFwvKSg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hMTAoPzpcXC5cXGR7MSwzfSl7M30pKD8hMTI3KD86XFwuXFxkezEsM30pezN9KSg/ITE2OVxcLjI1NCg/OlxcLlxcZHsxLDN9KXsyfSkoPyExOTJcXC4xNjgoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rLT8pKlthLXpcXHUwMGExLVxcdWZmZmYwLTldKykoPzpcXC4oPzpbYS16XFx1MDBhMS1cXHVmZmZmMC05XSstPykqW2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rKSooPzpcXC4oPzpbYS16XFx1MDBhMS1cXHVmZmZmXXsyLH0pKSkoPzo6XFxkezIsNX0pPyg/OlxcL1teXFxzXSopPyQvaTtcbiAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSk7XG59O1xudmFsaWRhdG9ySGFuZGxlcnMuYWxudW0gPSBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWdleCA9IC9eW2EtekEtWjAtOV0qJC87XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpO1xufTtcbnZhbGlkYXRvckhhbmRsZXJzLmNvbG9yID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcmVnZXggPSAvXiMoPzpbMC05YS1mXXszfSl7MSwyfSQvO1xuICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKTtcbn07XG4vKipcbiAqIEBzZWUgIGh0dHA6Ly93d3cudmlydHVvc2ltZWRpYS5jb20vZGV2L3BocC8zNy10ZXN0ZWQtcGhwLXBlcmwtYW5kLWphdmFzY3JpcHQtcmVndWxhci1leHByZXNzaW9uc1xuICovXG52YWxpZGF0b3JIYW5kbGVycy5jcmVkaXRjYXJkID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcmVnZXggPSAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2MDExWzAtOV17MTJ9fDYyMigoMTJbNi05XXwxWzMtOV1bMC05XSl8KFsyLThdWzAtOV1bMC05XSl8KDkoKFswLTFdWzAtOV0pfCgyWzAtNV0pKSkpWzAtOV17MTB9fDY0WzQtOV1bMC05XXsxM318NjVbMC05XXsxNH18Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fDNbNDddWzAtOV17MTN9KSokLztcbiAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSk7XG59O1xudmFsaWRhdG9ySGFuZGxlcnMuaXAgPSBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWdleCA9IC9eKCg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSkqJC87XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpO1xufTtcbnZhbGlkYXRvckhhbmRsZXJzWydwYXNzd29yZC1jb25maXJtJ10gPSBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGVsZW1lbnQuZGF0YXNldC5jb25maXJtVGFyZ2V0O1xuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWxpZGF0b3I6IFwicGFzc3dvcmQtY29uZmlybVwiIG11c3QgYWRkIFwiZGF0YS1jb25maXJtLXRhcmdldFwiIGF0dHJpYnV0ZS4nKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRhcmdldD8udmFsdWUgPT09IHZhbHVlO1xufTtcbmV4cG9ydCB7IHZhbGlkYXRvckhhbmRsZXJzIGFzIHZhbGlkYXRvcnMgfTtcbi8vIGN1c3RvbUVsZW1lbnRzLmRlZmluZShVbmljb3JuRm9ybVZhbGlkYXRlRWxlbWVudC5pcywgVW5pY29ybkZvcm1WYWxpZGF0ZUVsZW1lbnQpO1xuLy8gY3VzdG9tRWxlbWVudHMuZGVmaW5lKFVuaWNvcm5GaWVsZFZhbGlkYXRlRWxlbWVudC5pcywgVW5pY29ybkZpZWxkVmFsaWRhdGVFbGVtZW50KTtcbmV4cG9ydCBmdW5jdGlvbiBpbml0VmFsaWRhdGlvbnMoYXBwKSB7XG4gICAgY29uc3QgZGlyZWN0aXZlID0gYXBwLmluamVjdCgnJGRpcmVjdGl2ZScpO1xuICAgIGNvbnN0IGhlbHBlciA9IGFwcC5pbmplY3QoJyRoZWxwZXInKTtcbiAgICBkaXJlY3RpdmUucmVnaXN0ZXIoJ2Zvcm0tdmFsaWRhdGUnLCB7XG4gICAgICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGhlbHBlci5nZXRCb3VuZGVkSW5zdGFuY2UoZWwsICdmb3JtLnZhbGlkYXRpb24nLCAoZWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmljb3JuRm9ybVZhbGlkYXRpb24oYXBwLCBlbGUsIEpTT04ucGFyc2UoYmluZGluZy52YWx1ZSB8fCAne30nKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlZChlbCwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBoZWxwZXIuZ2V0Qm91bmRlZEluc3RhbmNlKGVsLCAnZm9ybS52YWxpZGF0aW9uJyk7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKEpTT04ucGFyc2UoYmluZGluZy52YWx1ZSB8fCAne30nKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkaXJlY3RpdmUucmVnaXN0ZXIoJ2ZpZWxkLXZhbGlkYXRlJywge1xuICAgICAgICBtb3VudGVkKGVsLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBoZWxwZXIuZ2V0Qm91bmRlZEluc3RhbmNlKGVsLCAnZmllbGQudmFsaWRhdGlvbicsIChlbGUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVuaWNvcm5GaWVsZFZhbGlkYXRpb24oYXBwLCBlbGUsIEpTT04ucGFyc2UoYmluZGluZy52YWx1ZSB8fCAne30nKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlZChlbCwgYmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBoZWxwZXIuZ2V0Qm91bmRlZEluc3RhbmNlKGVsLCAnZmllbGQudmFsaWRhdGlvbicpO1xuICAgICAgICAgICAgaW5zdGFuY2U/LnNldE9wdGlvbnMoSlNPTi5wYXJzZShiaW5kaW5nLnZhbHVlIHx8ICd7fScpIHx8IHt9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlUGFyYW1WYWx1ZSh2YWx1ZSkge1xuICAgIGlmICghaXNOYU4oTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/ui/validation-components.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/modules/ui/validation-components.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});