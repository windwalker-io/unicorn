/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["UnicornValidation"] = factory();
	else
		root["UnicornValidation"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../../../node_modules/punycode/punycode.es6.js":
/*!*********************************************************!*\
  !*** ../../../../node_modules/punycode/punycode.es6.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   toASCII: () => (/* binding */ toASCII),\n/* harmony export */   toUnicode: () => (/* binding */ toUnicode),\n/* harmony export */   ucs2decode: () => (/* binding */ ucs2decode),\n/* harmony export */   ucs2encode: () => (/* binding */ ucs2encode)\n/* harmony export */ });\n\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (punycode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLi9zcmMvbW9kdWxlcy91aS92YWxpZGF0aW9uLWNvbXBvbmVudHMudHMvLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmVzNi5qcz8yMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCB0TWluID0gMTtcbmNvbnN0IHRNYXggPSAyNjtcbmNvbnN0IHNrZXcgPSAzODtcbmNvbnN0IGRhbXAgPSA3MDA7XG5jb25zdCBpbml0aWFsQmlhcyA9IDcyO1xuY29uc3QgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbmNvbnN0IGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuY29uc3QgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdGXS87IC8vIE5vdGU6IFUrMDA3RiBERUwgaXMgZXhjbHVkZWQgdG9vLlxuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbmNvbnN0IGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbmNvbnN0IGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBjYWxsYmFjaykge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBjYWxsYmFjayhhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihkb21haW4sIGNhbGxiYWNrKSB7XG5cdGNvbnN0IHBhcnRzID0gZG9tYWluLnNwbGl0KCdAJyk7XG5cdGxldCByZXN1bHQgPSAnJztcblx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRkb21haW4gPSBwYXJ0c1sxXTtcblx0fVxuXHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdGRvbWFpbiA9IGRvbWFpbi5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdGNvbnN0IGxhYmVscyA9IGRvbWFpbi5zcGxpdCgnLicpO1xuXHRjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgY2FsbGJhY2spLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRsZXQgY291bnRlciA9IDA7XG5cdGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHRjb25zdCBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cblx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG5cdFx0XHRcdC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGVuY29kZVxuICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cbiAqL1xuY29uc3QgdWNzMmVuY29kZSA9IGNvZGVQb2ludHMgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xuY29uc3QgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHgzMCAmJiBjb2RlUG9pbnQgPCAweDNBKSB7XG5cdFx0cmV0dXJuIDI2ICsgKGNvZGVQb2ludCAtIDB4MzApO1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgPj0gMHg0MSAmJiBjb2RlUG9pbnQgPCAweDVCKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCA+PSAweDYxICYmIGNvZGVQb2ludCA8IDB4N0IpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xuY29uc3QgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0bGV0IGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0bGV0IGkgPSAwO1xuXHRsZXQgbiA9IGluaXRpYWxOO1xuXHRsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yIChsZXQgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0Y29uc3Qgb2xkaSA9IGk7XG5cdFx0Zm9yIChsZXQgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdGlmIChkaWdpdCA+PSBiYXNlKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xuY29uc3QgZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGRlbHRhID0gMDtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHRsZXQgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRsZXQgbSA9IG1heEludDtcblx0XHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG5cdFx0Y29uc3QgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlID09PSBuKSB7XG5cdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRsZXQgcSA9IGRlbHRhO1xuXHRcdFx0XHRmb3IgKGxldCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQrK2RlbHRhO1xuXHRcdCsrbjtcblxuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG5jb25zdCB0b1VuaWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuY29uc3QgdG9BU0NJSSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0OiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbmNvbnN0IHB1bnljb2RlID0ge1xuXHQvKipcblx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQndmVyc2lvbic6ICcyLjMuMScsXG5cdC8qKlxuXHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG5leHBvcnQgeyB1Y3MyZGVjb2RlLCB1Y3MyZW5jb2RlLCBkZWNvZGUsIGVuY29kZSwgdG9BU0NJSSwgdG9Vbmljb2RlIH07XG5leHBvcnQgZGVmYXVsdCBwdW55Y29kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../../node_modules/punycode/punycode.es6.js\n");

/***/ }),

/***/ "./src/modules/ui/validation-components.ts":
/*!*************************************************!*\
  !*** ./src/modules/ui/validation-components.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnicornFieldValidation: () => (/* binding */ UnicornFieldValidation),\n/* harmony export */   UnicornFormValidation: () => (/* binding */ UnicornFormValidation),\n/* harmony export */   initValidations: () => (/* binding */ initValidations),\n/* harmony export */   validators: () => (/* binding */ validatorHandlers)\n/* harmony export */ });\n/* harmony import */ var punycode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! punycode */ \"../../../../node_modules/punycode/punycode.es6.js\");\n\nconst validatorHandlers = {};\nconst defaultOptions = {\n    scroll: false,\n    scrollOffset: -100,\n    enabled: true,\n    fieldSelector: null,\n    validatedClass: null,\n};\nconst defaultFieldOptions = {\n    formSelector: '[uni-form-validate]',\n    errorSelector: '[data-field-error]',\n    selector: 'input[data-field-input], select[data-field-input], textarea[data-field-input]',\n    validClass: 'is-valid',\n    invalidClass: 'is-invalid',\n    events: ['change'],\n    errorMessageClass: 'invalid-tooltip',\n    inputOptions: false,\n    inputOptionsWrapperSelector: 'div[data-field-input]',\n    inputOptionsSelector: '[data-input-option]'\n};\nclass UnicornFormValidation {\n    app;\n    presetFields = [];\n    static globalValidators = {};\n    validators = {};\n    options;\n    $form;\n    static is = 'uni-form-validate';\n    constructor(app, el, options = {}) {\n        this.app = app;\n        this.$form = this.$helper.selectOne(el);\n        this.options = this.$helper.defaultsDeep({}, options, defaultOptions);\n        this.registerDefaultValidators();\n        this.init();\n    }\n    get $helper() {\n        return this.app.inject('$helper');\n    }\n    get $ui() {\n        return this.app.inject('$ui');\n    }\n    get $lang() {\n        return this.app.inject('$lang');\n    }\n    setOptions(options) {\n        this.options = this.$helper.defaultsDeep({}, options, defaultOptions);\n    }\n    get scrollEnabled() {\n        return this.options.scroll;\n    }\n    get scrollOffset() {\n        return Number(this.options.scrollOffset || -100);\n    }\n    get fieldSelector() {\n        return this.options.fieldSelector || 'input, select, textarea';\n    }\n    get validatedClass() {\n        return this.options.validatedClass || 'was-validated';\n    }\n    init() {\n        if (this.$form.tagName === 'FORM') {\n            this.$form.setAttribute('novalidate', 'true');\n            this.$form.addEventListener('submit', (event) => {\n                if (this.options.enabled && !this.validateAll()) {\n                    event.stopImmediatePropagation(); // Stop following events\n                    event.stopPropagation();\n                    event.preventDefault();\n                    this.$form.dispatchEvent(new CustomEvent('invalid'));\n                    return false;\n                }\n                return true;\n            }, false);\n        }\n        this.prepareFields(this.findDOMFields());\n        this.prepareFields(this.presetFields);\n    }\n    findDOMFields() {\n        return this.$helper.selectAll(this.$form.querySelectorAll(this.fieldSelector));\n    }\n    prepareFields(inputs) {\n        inputs.forEach((input) => {\n            this.prepareFieldWrapper(input);\n        });\n        // Wait next tick\n        return Promise.resolve();\n    }\n    prepareFieldWrapper(input) {\n        if (['INPUT', 'SELECT', 'TEXTAREA'].indexOf(input.tagName) !== -1) {\n            let wrapper = input.closest('[uni-field-validate]');\n            if (!wrapper) {\n                wrapper = input.closest('[data-input-container]') || input.parentElement;\n                wrapper?.setAttribute('uni-field-validate', '{}');\n            }\n            return wrapper;\n        }\n        return input;\n    }\n    findFields(containsPresets = true) {\n        let inputs = this.findDOMFields();\n        if (containsPresets) {\n            inputs.push(...this.presetFields);\n        }\n        return inputs.map((input) => this.prepareFieldWrapper(input))\n            .filter(input => input != null);\n    }\n    getFieldComponent(input) {\n        let v = this.$helper.getBoundedInstance(input, 'field.validation');\n        if (!v) {\n            const wrapper = input.closest('[uni-field-validate]');\n            if (wrapper) {\n                v = this.$helper.getBoundedInstance(wrapper, 'field.validation');\n            }\n        }\n        return v;\n    }\n    validateAll(fields) {\n        this.markFormAsUnvalidated();\n        fields = fields || this.findFields();\n        let firstFail = null;\n        for (const field of fields) {\n            const fv = this.getFieldComponent(field);\n            if (!fv) {\n                continue;\n            }\n            const result = fv.checkValidity();\n            if (!result && !firstFail) {\n                firstFail = field;\n            }\n        }\n        this.markFormAsValidated();\n        if (firstFail && this.scrollEnabled) {\n            this.scrollTo(firstFail);\n        }\n        return firstFail === null;\n    }\n    async validateAllAsync(fields) {\n        this.markFormAsUnvalidated();\n        fields = fields || this.findFields();\n        let firstFail = null;\n        const promises = [];\n        for (const field of fields) {\n            const fv = this.getFieldComponent(field);\n            if (!fv) {\n                continue;\n            }\n            promises.push(fv.checkValidityAsync().then((result) => {\n                if (!result && !firstFail) {\n                    firstFail = field;\n                }\n                return result;\n            }));\n        }\n        await Promise.all(promises);\n        this.markFormAsValidated();\n        if (firstFail && this.scrollEnabled) {\n            this.scrollTo(firstFail);\n        }\n        return firstFail === null;\n    }\n    scrollTo(element) {\n        const offset = this.scrollOffset;\n        const elementPosition = element.getBoundingClientRect().top;\n        const offsetPosition = elementPosition + window.scrollY + offset;\n        window.scrollTo({\n            top: offsetPosition,\n            behavior: 'smooth'\n        });\n    }\n    markFormAsValidated() {\n        if (!this.$form) {\n            return;\n        }\n        this.$form.classList.add(this.validatedClass);\n    }\n    markFormAsUnvalidated() {\n        if (!this.$form) {\n            return;\n        }\n        this.$form.classList.remove(this.validatedClass);\n    }\n    addField(field) {\n        this.presetFields.push(field);\n        this.prepareFieldWrapper(field);\n        return this;\n    }\n    registerDefaultValidators() {\n        for (let name in validatorHandlers) {\n            this.addValidator(name, validatorHandlers[name]);\n        }\n    }\n    /**\n     * Add validator handler.\n     */\n    addValidator(name, handler, options = {}) {\n        options = options || {};\n        this.validators[name] = {\n            handler,\n            options\n        };\n        return this;\n    }\n    /**\n     * Add validator handler.\n     */\n    static addGlobalValidator(name, handler, options = {}) {\n        options = options || {};\n        this.globalValidators[name] = {\n            handler,\n            options\n        };\n        return this;\n    }\n}\nclass UnicornFieldValidation {\n    app;\n    el;\n    $input;\n    options;\n    static is = 'uni-field-validate';\n    constructor(app, el, options = {}) {\n        this.app = app;\n        this.el = el;\n        this.options = this.$helper.defaultsDeep({}, options, defaultFieldOptions);\n        this.$input = this.selectInput();\n        this.init();\n    }\n    get $helper() {\n        return this.app.inject('$helper');\n    }\n    get $lang() {\n        return this.app.inject('$lang');\n    }\n    get $ui() {\n        return this.app.inject('$ui');\n    }\n    setOptions(options) {\n        this.options = this.$helper.defaultsDeep({}, options, defaultFieldOptions);\n    }\n    get $form() {\n        return this.getForm();\n    }\n    get errorSelector() {\n        return this.options.errorSelector;\n    }\n    get selector() {\n        return this.options.selector;\n    }\n    get validClass() {\n        return this.options.validClass;\n    }\n    get invalidClass() {\n        return this.options.invalidClass;\n    }\n    get isVisible() {\n        return !!(this.el.offsetWidth || this.el.offsetHeight || this.el.getClientRects().length);\n    }\n    get isInputOptions() {\n        return Boolean(this.options.inputOptions);\n    }\n    get validationMessage() {\n        return this.$input?.validationMessage || '';\n    }\n    get validity() {\n        return this.$input?.validity;\n    }\n    selectInput() {\n        let selector = this.selector;\n        if (this.options.inputOptions) {\n            selector += ', ' + this.options.inputOptionsWrapperSelector;\n        }\n        let input = this.el.querySelector(selector);\n        if (!input) {\n            input = this.el.querySelector('input, select, textarea');\n        }\n        if (!input) {\n            throw new Error('Input not found');\n        }\n        return this.$input = input;\n    }\n    init() {\n        this.selectInput();\n        this.bindEvents();\n        this.prepareWrapper();\n        if (this.isInputOptions) {\n            const $input = this.$input;\n            $input.validationMessage = '';\n            $input.setCustomValidity = (msg) => {\n                $input.validationMessage = String(msg);\n            };\n            $input.checkValidity = () => {\n                return this.checkInputOptionsValidity();\n            };\n        }\n    }\n    bindEvents() {\n        if (!this.$input) {\n            return;\n        }\n        this.$input.addEventListener('invalid', (e) => {\n            this.showInvalidResponse();\n        });\n        const events = this.options.events;\n        events.forEach((eventName) => {\n            this.$input.addEventListener(eventName, () => {\n                this.checkValidity();\n            });\n        });\n    }\n    prepareWrapper() {\n        if (this.el.querySelector(this.errorSelector)?.classList?.contains('invalid-tooltip')) {\n            if (window.getComputedStyle(this.el).position === 'static') {\n                this.el.style.position = 'relative';\n            }\n        }\n    }\n    checkValidity() {\n        if (!this.$input) {\n            return true;\n        }\n        if (this.$input.hasAttribute('readonly')) {\n            return true;\n        }\n        if (this.$input.hasAttribute('[data-novalidate]')) {\n            return true;\n        }\n        if (this.$input.closest('[data-novalidate]')) {\n            return true;\n        }\n        this.$input.setCustomValidity('');\n        let valid = this.$input.checkValidity();\n        if (valid && this.$form) {\n            valid = this.runCustomValidity();\n        }\n        // Raise invalid event\n        // this.$input.checkValidity();\n        this.updateValidClass(valid);\n        return valid;\n    }\n    runCustomValidity() {\n        // Check custom validity\n        const validates = (this.$input.getAttribute('data-validate') || '').split('|');\n        let result = true;\n        if (this.$input.value !== '' && validates.length) {\n            if (!this.checkCustomDataAttributeValidity()) {\n                return false;\n            }\n            for (const validatorName of validates) {\n                const [validator, options] = this.getValidator(validatorName) || [null, {}];\n                if (!validator) {\n                    continue;\n                }\n                Object.assign(options, validator.options);\n                let r = validator.handler(this.$input.value, this.$input, options, this);\n                // If return is a promise, push to stack and resolve later\n                if (r instanceof Promise || (typeof r === 'object' && r.then)) {\n                    r.then((result) => {\n                        this.handleAsyncCustomResult(result, validator);\n                    });\n                    continue;\n                }\n                if (!this.handleCustomResult(r, validator)) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    async checkValidityAsync() {\n        if (!this.$input) {\n            return true;\n        }\n        if (this.$input.hasAttribute('readonly')) {\n            return true;\n        }\n        this.$input.setCustomValidity('');\n        let valid = this.$input.checkValidity();\n        if (valid && this.$form) {\n            valid = await this.runCustomValidityAsync();\n        }\n        this.updateValidClass(valid);\n        return valid;\n    }\n    async runCustomValidityAsync() {\n        // Check custom validity\n        const validates = (this.$input.getAttribute('data-validate') || '').split('|');\n        const results = [];\n        const promises = [];\n        if (this.$input.value !== '' && validates.length) {\n            if (!this.checkCustomDataAttributeValidity()) {\n                return false;\n            }\n            for (const validatorName of validates) {\n                let [validator, options] = this.getValidator(validatorName) || [null, {}];\n                if (!validator) {\n                    continue;\n                }\n                options = Object.assign({}, options, validator.options || {});\n                promises.push(Promise.resolve(validator.handler(this.$input.value, this.$input, options, this))\n                    .then((r) => {\n                    results.push(this.handleAsyncCustomResult(r, validator));\n                    return r;\n                }));\n            }\n        }\n        await Promise.all(promises);\n        for (const result of results) {\n            if (result === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    checkCustomDataAttributeValidity() {\n        const error = this.$input.dataset.validationFail;\n        return this.handleCustomResult(error);\n    }\n    checkInputOptionsValidity() {\n        const isRequired = this.$input.getAttribute('required') != null;\n        const optionWrappers = this.$input.querySelectorAll(this.options.inputOptionsSelector);\n        let result = true;\n        if (isRequired) {\n            for (const optionWrapper of optionWrappers) {\n                const input = optionWrapper.querySelector('input');\n                result = false;\n                // Only need one checked\n                if (input?.checked) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n        // Get browser input validation message\n        const n = document.createElement('input');\n        n.required = isRequired;\n        if (result) {\n            n.value = 'placeholder';\n        }\n        n.checkValidity();\n        this.$input.validationMessage = n.validationMessage;\n        this.$input.validity = n.validity;\n        for (const optionWrapper of optionWrappers) {\n            const input = optionWrapper.querySelector('input');\n            input?.setCustomValidity(n.validationMessage);\n        }\n        if (!result) {\n            this.$input.dispatchEvent(new CustomEvent('invalid'));\n        }\n        return result;\n    }\n    /**\n     * @param valid {boolean}\n     */\n    updateValidClass(valid) {\n        this.$input.classList.remove(this.invalidClass);\n        this.$input.classList.remove(this.validClass);\n        this.el.classList.remove(this.invalidClass);\n        this.el.classList.remove(this.validClass);\n        if (valid) {\n            this.$input.classList.add(this.validClass);\n            this.el.classList.add(this.validClass);\n        }\n        else {\n            this.$input.classList.add(this.invalidClass);\n            this.el.classList.add(this.invalidClass);\n        }\n    }\n    getFormValidation(element) {\n        return this.$helper.getBoundedInstance(element || this.getForm(), 'form.validation');\n    }\n    getValidator(name) {\n        const matches = name.match(/(?<type>[\\w\\-_]+)(\\((?<params>.*)\\))*/);\n        if (!matches) {\n            return null;\n        }\n        const validatorName = matches.groups?.type || '';\n        const params = matches.groups?.params || '';\n        const fv = this.getFormValidation(this.$form);\n        const validator = fv?.validators[validatorName] || UnicornFormValidation.globalValidators[validatorName];\n        if (!validator) {\n            return null;\n        }\n        const paramMatches = params.matchAll(/(?<key>\\w+)(\\s?[=:]\\s?(?<value>\\w+))?/g);\n        const options = {};\n        for (const paramMatch of paramMatches) {\n            const match = paramMatch?.groups;\n            if (!match) {\n                continue;\n            }\n            options[match.key] = handleParamValue(match.value);\n        }\n        return [validator, options];\n    }\n    handleCustomResult(result, validator) {\n        if (typeof result === 'string') {\n            this.$input.setCustomValidity(result);\n            result = result === '';\n        }\n        else if (result === undefined) {\n            result = true;\n        }\n        if (result) {\n            this.$input.setCustomValidity('');\n        }\n        else if (validator) {\n            this.raiseCustomErrorState(validator);\n        }\n        return result;\n    }\n    handleAsyncCustomResult(result, validator) {\n        result = this.handleCustomResult(result, validator);\n        // Fire invalid events\n        this.$input.checkValidity();\n        this.updateValidClass(result);\n        return result;\n    }\n    raiseCustomErrorState(validator) {\n        let help;\n        if (this.$input.validationMessage === '') {\n            help = validator.options?.notice;\n            if (typeof help === 'function') {\n                help = help(this.$input, this);\n            }\n            if (help != null) {\n                this.$input.setCustomValidity(help);\n            }\n        }\n        if (this.$input.validationMessage === '') {\n            this.$input.setCustomValidity(this.$lang.__('unicorn.message.validation.custom.error'));\n        }\n        this.$input.dispatchEvent(new CustomEvent('invalid'));\n    }\n    setAsInvalidAndReport(error) {\n        this.setCustomValidity(error);\n        this.showInvalidResponse();\n    }\n    setCustomValidity(error) {\n        this.$input.setCustomValidity(error);\n    }\n    reportValidity() {\n        if (this.validationMessage !== '') {\n            this.showInvalidResponse();\n        }\n    }\n    showInvalidResponse() {\n        this.updateValidClass(false);\n        /** @type ValidityState */\n        const state = this.$input.validity;\n        let message = this.$input.validationMessage;\n        for (let key in state) {\n            if (state[key] && this.$input.dataset[key + 'Message']) {\n                message = this.$input.dataset[key + 'Message'] || '';\n                break;\n            }\n        }\n        if (!this.isVisible) {\n            let title = this.findLabel()?.textContent;\n            if (!title) {\n                title = this.$input.name;\n            }\n            this.$ui.renderMessage(`Field: ${title} - ${message}`, 'warning');\n        }\n        let $help = this.el.querySelector(this.errorSelector);\n        if (!$help) {\n            $help = this.createHelpElement();\n            this.el.appendChild($help);\n            this.prepareWrapper();\n        }\n        $help.textContent = message;\n    }\n    createHelpElement() {\n        const className = this.options.errorMessageClass;\n        const parsed = this.parseSelector(this.errorSelector || '');\n        const $help = this.$helper.html(`<div class=\"${className}\"></div>`);\n        $help.classList.add(...parsed.classes);\n        parsed.attrs.forEach((attr) => {\n            $help.setAttribute(attr[0], attr[1] || '');\n        });\n        parsed.ids.forEach((id) => {\n            $help.id = id;\n        });\n        return $help;\n    }\n    /**\n     * @see https://stackoverflow.com/a/17888178\n     */\n    parseSelector(subselector) {\n        const obj = { tags: [], classes: [], ids: [], attrs: [] };\n        for (const token of subselector.split(/(?=\\.)|(?=#)|(?=\\[)/)) {\n            switch (token[0]) {\n                case '#':\n                    obj.ids.push(token.slice(1));\n                    break;\n                case '.':\n                    obj.classes.push(token.slice(1));\n                    break;\n                case '[':\n                    obj.attrs.push(token.slice(1, -1).split('='));\n                    break;\n                default:\n                    obj.tags.push(token);\n                    break;\n            }\n        }\n        return obj;\n    }\n    setAsValidAndClearResponse() {\n        this.setCustomValidity('');\n        this.updateValidClass(true);\n        this.clearInvalidResponse();\n    }\n    clearInvalidResponse() {\n        const $help = this.el.querySelector(this.errorSelector);\n        $help.textContent = '';\n    }\n    getForm() {\n        return this.el.closest(this.options.formSelector || '[uni-form-validate]');\n    }\n    findLabel() {\n        const id = this.$input.id;\n        const wrapper = this.$input.closest('[data-field-wrapper]');\n        let label = null;\n        if (wrapper) {\n            label = wrapper.querySelector('[data-field-label]');\n        }\n        if (!label) {\n            label = document.querySelector(`label[for=\"${id}\"]`);\n        }\n        return label;\n    }\n}\nfunction camelTo(str, sep) {\n    return str.replace(/([a-z])([A-Z])/g, `$1${sep}$2`).toLowerCase();\n}\nvalidatorHandlers.username = function (value, element) {\n    const regex = new RegExp('[\\<|\\>|\"|\\'|\\%|\\;|\\(|\\)|\\&]', 'i');\n    return !regex.test(value);\n};\nvalidatorHandlers.numeric = function (value, element) {\n    const regex = /^(\\d|-)?(\\d|,)*\\.?\\d*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.email = function (value, element) {\n    value = punycode__WEBPACK_IMPORTED_MODULE_0__.toASCII(value);\n    const regex = /^[a-zA-Z0-9.!#$%&*+\\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.url = function (value, element) {\n    const regex = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-?)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/i;\n    return regex.test(value);\n};\nvalidatorHandlers.alnum = function (value, element) {\n    const regex = /^[a-zA-Z0-9]*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.color = function (value, element) {\n    const regex = /^#(?:[0-9a-f]{3}){1,2}$/;\n    return regex.test(value);\n};\n/**\n * @see  http://www.virtuosimedia.com/dev/php/37-tested-php-perl-and-javascript-regular-expressions\n */\nvalidatorHandlers.creditcard = function (value, element) {\n    const regex = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6011[0-9]{12}|622((12[6-9]|1[3-9][0-9])|([2-8][0-9][0-9])|(9(([0-1][0-9])|(2[0-5]))))[0-9]{10}|64[4-9][0-9]{13}|65[0-9]{14}|3(?:0[0-5]|[68][0-9])[0-9]{11}|3[47][0-9]{13})*$/;\n    return regex.test(value);\n};\nvalidatorHandlers.ip = function (value, element) {\n    const regex = /^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$/;\n    return regex.test(value);\n};\nvalidatorHandlers['password-confirm'] = function (value, element) {\n    const selector = element.dataset.confirmTarget;\n    if (!selector) {\n        throw new Error('Validator: \"password-confirm\" must add \"data-confirm-target\" attribute.');\n    }\n    const target = document.querySelector(selector);\n    return target?.value === value;\n};\n\n// customElements.define(UnicornFormValidateElement.is, UnicornFormValidateElement);\n// customElements.define(UnicornFieldValidateElement.is, UnicornFieldValidateElement);\nfunction initValidations(app) {\n    const directive = app.inject('$directive');\n    const helper = app.inject('$helper');\n    directive.register('form-validate', {\n        mounted(el, binding) {\n            helper.getBoundedInstance(el, 'form.validation', (ele) => {\n                return new UnicornFormValidation(app, ele, JSON.parse(binding.value || '{}'));\n            });\n        },\n        updated(el, binding) {\n            const instance = helper.getBoundedInstance(el, 'form.validation');\n            instance.setOptions(JSON.parse(binding.value || '{}'));\n        }\n    });\n    directive.register('field-validate', {\n        mounted(el, binding) {\n            helper.getBoundedInstance(el, 'field.validation', (ele) => {\n                return new UnicornFieldValidation(app, ele, JSON.parse(binding.value || '{}'));\n            });\n        },\n        updated(el, binding) {\n            const instance = helper.getBoundedInstance(el, 'field.validation');\n            instance?.setOptions(JSON.parse(binding.value || '{}') || {});\n        }\n    });\n}\nfunction handleParamValue(value) {\n    if (!isNaN(Number(value))) {\n        return Number(value);\n    }\n    if (value === 'null') {\n        return null;\n    }\n    if (value === 'true') {\n        return true;\n    }\n    if (value === 'false') {\n        return true;\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy91aS92YWxpZGF0aW9uLWNvbXBvbmVudHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9tb2R1bGVzL3VpL3ZhbGlkYXRpb24tY29tcG9uZW50cy50cy8uL3NyYy9tb2R1bGVzL3VpL3ZhbGlkYXRpb24tY29tcG9uZW50cy50cz8wMTQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHB1bnljb2RlIGZyb20gJ3B1bnljb2RlJztcbmNvbnN0IHZhbGlkYXRvckhhbmRsZXJzID0ge307XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBzY3JvbGw6IGZhbHNlLFxuICAgIHNjcm9sbE9mZnNldDogLTEwMCxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZpZWxkU2VsZWN0b3I6IG51bGwsXG4gICAgdmFsaWRhdGVkQ2xhc3M6IG51bGwsXG59O1xuY29uc3QgZGVmYXVsdEZpZWxkT3B0aW9ucyA9IHtcbiAgICBmb3JtU2VsZWN0b3I6ICdbdW5pLWZvcm0tdmFsaWRhdGVdJyxcbiAgICBlcnJvclNlbGVjdG9yOiAnW2RhdGEtZmllbGQtZXJyb3JdJyxcbiAgICBzZWxlY3RvcjogJ2lucHV0W2RhdGEtZmllbGQtaW5wdXRdLCBzZWxlY3RbZGF0YS1maWVsZC1pbnB1dF0sIHRleHRhcmVhW2RhdGEtZmllbGQtaW5wdXRdJyxcbiAgICB2YWxpZENsYXNzOiAnaXMtdmFsaWQnLFxuICAgIGludmFsaWRDbGFzczogJ2lzLWludmFsaWQnLFxuICAgIGV2ZW50czogWydjaGFuZ2UnXSxcbiAgICBlcnJvck1lc3NhZ2VDbGFzczogJ2ludmFsaWQtdG9vbHRpcCcsXG4gICAgaW5wdXRPcHRpb25zOiBmYWxzZSxcbiAgICBpbnB1dE9wdGlvbnNXcmFwcGVyU2VsZWN0b3I6ICdkaXZbZGF0YS1maWVsZC1pbnB1dF0nLFxuICAgIGlucHV0T3B0aW9uc1NlbGVjdG9yOiAnW2RhdGEtaW5wdXQtb3B0aW9uXSdcbn07XG5leHBvcnQgY2xhc3MgVW5pY29ybkZvcm1WYWxpZGF0aW9uIHtcbiAgICBhcHA7XG4gICAgcHJlc2V0RmllbGRzID0gW107XG4gICAgc3RhdGljIGdsb2JhbFZhbGlkYXRvcnMgPSB7fTtcbiAgICB2YWxpZGF0b3JzID0ge307XG4gICAgb3B0aW9ucztcbiAgICAkZm9ybTtcbiAgICBzdGF0aWMgaXMgPSAndW5pLWZvcm0tdmFsaWRhdGUnO1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy4kZm9ybSA9IHRoaXMuJGhlbHBlci5zZWxlY3RPbmUoZWwpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLiRoZWxwZXIuZGVmYXVsdHNEZWVwKHt9LCBvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJEZWZhdWx0VmFsaWRhdG9ycygpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgZ2V0ICRoZWxwZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcC5pbmplY3QoJyRoZWxwZXInKTtcbiAgICB9XG4gICAgZ2V0ICR1aSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmluamVjdCgnJHVpJyk7XG4gICAgfVxuICAgIGdldCAkbGFuZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmluamVjdCgnJGxhbmcnKTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuJGhlbHBlci5kZWZhdWx0c0RlZXAoe30sIG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IHNjcm9sbEVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2Nyb2xsO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMub3B0aW9ucy5zY3JvbGxPZmZzZXQgfHwgLTEwMCk7XG4gICAgfVxuICAgIGdldCBmaWVsZFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpZWxkU2VsZWN0b3IgfHwgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJztcbiAgICB9XG4gICAgZ2V0IHZhbGlkYXRlZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbGlkYXRlZENsYXNzIHx8ICd3YXMtdmFsaWRhdGVkJztcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGZvcm0udGFnTmFtZSA9PT0gJ0ZPUk0nKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtLnNldEF0dHJpYnV0ZSgnbm92YWxpZGF0ZScsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLiRmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCAmJiAhdGhpcy52YWxpZGF0ZUFsbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyAvLyBTdG9wIGZvbGxvd2luZyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2ludmFsaWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwYXJlRmllbGRzKHRoaXMuZmluZERPTUZpZWxkcygpKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlRmllbGRzKHRoaXMucHJlc2V0RmllbGRzKTtcbiAgICB9XG4gICAgZmluZERPTUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGhlbHBlci5zZWxlY3RBbGwodGhpcy4kZm9ybS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuZmllbGRTZWxlY3RvcikpO1xuICAgIH1cbiAgICBwcmVwYXJlRmllbGRzKGlucHV0cykge1xuICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZUZpZWxkV3JhcHBlcihpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXYWl0IG5leHQgdGlja1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHByZXBhcmVGaWVsZFdyYXBwZXIoaW5wdXQpIHtcbiAgICAgICAgaWYgKFsnSU5QVVQnLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ10uaW5kZXhPZihpbnB1dC50YWdOYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gaW5wdXQuY2xvc2VzdCgnW3VuaS1maWVsZC12YWxpZGF0ZV0nKTtcbiAgICAgICAgICAgIGlmICghd3JhcHBlcikge1xuICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBpbnB1dC5jbG9zZXN0KCdbZGF0YS1pbnB1dC1jb250YWluZXJdJykgfHwgaW5wdXQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICB3cmFwcGVyPy5zZXRBdHRyaWJ1dGUoJ3VuaS1maWVsZC12YWxpZGF0ZScsICd7fScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBmaW5kRmllbGRzKGNvbnRhaW5zUHJlc2V0cyA9IHRydWUpIHtcbiAgICAgICAgbGV0IGlucHV0cyA9IHRoaXMuZmluZERPTUZpZWxkcygpO1xuICAgICAgICBpZiAoY29udGFpbnNQcmVzZXRzKSB7XG4gICAgICAgICAgICBpbnB1dHMucHVzaCguLi50aGlzLnByZXNldEZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0cy5tYXAoKGlucHV0KSA9PiB0aGlzLnByZXBhcmVGaWVsZFdyYXBwZXIoaW5wdXQpKVxuICAgICAgICAgICAgLmZpbHRlcihpbnB1dCA9PiBpbnB1dCAhPSBudWxsKTtcbiAgICB9XG4gICAgZ2V0RmllbGRDb21wb25lbnQoaW5wdXQpIHtcbiAgICAgICAgbGV0IHYgPSB0aGlzLiRoZWxwZXIuZ2V0Qm91bmRlZEluc3RhbmNlKGlucHV0LCAnZmllbGQudmFsaWRhdGlvbicpO1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBpbnB1dC5jbG9zZXN0KCdbdW5pLWZpZWxkLXZhbGlkYXRlXScpO1xuICAgICAgICAgICAgaWYgKHdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICB2ID0gdGhpcy4kaGVscGVyLmdldEJvdW5kZWRJbnN0YW5jZSh3cmFwcGVyLCAnZmllbGQudmFsaWRhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICB2YWxpZGF0ZUFsbChmaWVsZHMpIHtcbiAgICAgICAgdGhpcy5tYXJrRm9ybUFzVW52YWxpZGF0ZWQoKTtcbiAgICAgICAgZmllbGRzID0gZmllbGRzIHx8IHRoaXMuZmluZEZpZWxkcygpO1xuICAgICAgICBsZXQgZmlyc3RGYWlsID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ2ID0gdGhpcy5nZXRGaWVsZENvbXBvbmVudChmaWVsZCk7XG4gICAgICAgICAgICBpZiAoIWZ2KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmdi5jaGVja1ZhbGlkaXR5KCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiAhZmlyc3RGYWlsKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RGYWlsID0gZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRm9ybUFzVmFsaWRhdGVkKCk7XG4gICAgICAgIGlmIChmaXJzdEZhaWwgJiYgdGhpcy5zY3JvbGxFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvKGZpcnN0RmFpbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0RmFpbCA9PT0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVBbGxBc3luYyhmaWVsZHMpIHtcbiAgICAgICAgdGhpcy5tYXJrRm9ybUFzVW52YWxpZGF0ZWQoKTtcbiAgICAgICAgZmllbGRzID0gZmllbGRzIHx8IHRoaXMuZmluZEZpZWxkcygpO1xuICAgICAgICBsZXQgZmlyc3RGYWlsID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ2ID0gdGhpcy5nZXRGaWVsZENvbXBvbmVudChmaWVsZCk7XG4gICAgICAgICAgICBpZiAoIWZ2KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGZ2LmNoZWNrVmFsaWRpdHlBc3luYygpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0ICYmICFmaXJzdEZhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RGYWlsID0gZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB0aGlzLm1hcmtGb3JtQXNWYWxpZGF0ZWQoKTtcbiAgICAgICAgaWYgKGZpcnN0RmFpbCAmJiB0aGlzLnNjcm9sbEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8oZmlyc3RGYWlsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3RGYWlsID09PSBudWxsO1xuICAgIH1cbiAgICBzY3JvbGxUbyhlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuc2Nyb2xsT2Zmc2V0O1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zaXRpb24gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0UG9zaXRpb24gPSBlbGVtZW50UG9zaXRpb24gKyB3aW5kb3cuc2Nyb2xsWSArIG9mZnNldDtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgICAgICAgIHRvcDogb2Zmc2V0UG9zaXRpb24sXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1hcmtGb3JtQXNWYWxpZGF0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGZvcm0uY2xhc3NMaXN0LmFkZCh0aGlzLnZhbGlkYXRlZENsYXNzKTtcbiAgICB9XG4gICAgbWFya0Zvcm1Bc1VudmFsaWRhdGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRmb3JtLmNsYXNzTGlzdC5yZW1vdmUodGhpcy52YWxpZGF0ZWRDbGFzcyk7XG4gICAgfVxuICAgIGFkZEZpZWxkKGZpZWxkKSB7XG4gICAgICAgIHRoaXMucHJlc2V0RmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICB0aGlzLnByZXBhcmVGaWVsZFdyYXBwZXIoZmllbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVnaXN0ZXJEZWZhdWx0VmFsaWRhdG9ycygpIHtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB2YWxpZGF0b3JIYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5hZGRWYWxpZGF0b3IobmFtZSwgdmFsaWRhdG9ySGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB2YWxpZGF0b3IgaGFuZGxlci5cbiAgICAgKi9cbiAgICBhZGRWYWxpZGF0b3IobmFtZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLnZhbGlkYXRvcnNbbmFtZV0gPSB7XG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHZhbGlkYXRvciBoYW5kbGVyLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHbG9iYWxWYWxpZGF0b3IobmFtZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmdsb2JhbFZhbGlkYXRvcnNbbmFtZV0gPSB7XG4gICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5pY29ybkZpZWxkVmFsaWRhdGlvbiB7XG4gICAgYXBwO1xuICAgIGVsO1xuICAgICRpbnB1dDtcbiAgICBvcHRpb25zO1xuICAgIHN0YXRpYyBpcyA9ICd1bmktZmllbGQtdmFsaWRhdGUnO1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLiRoZWxwZXIuZGVmYXVsdHNEZWVwKHt9LCBvcHRpb25zLCBkZWZhdWx0RmllbGRPcHRpb25zKTtcbiAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLnNlbGVjdElucHV0KCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBnZXQgJGhlbHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmluamVjdCgnJGhlbHBlcicpO1xuICAgIH1cbiAgICBnZXQgJGxhbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcC5pbmplY3QoJyRsYW5nJyk7XG4gICAgfVxuICAgIGdldCAkdWkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcC5pbmplY3QoJyR1aScpO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy4kaGVscGVyLmRlZmF1bHRzRGVlcCh7fSwgb3B0aW9ucywgZGVmYXVsdEZpZWxkT3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCAkZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybSgpO1xuICAgIH1cbiAgICBnZXQgZXJyb3JTZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lcnJvclNlbGVjdG9yO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2VsZWN0b3I7XG4gICAgfVxuICAgIGdldCB2YWxpZENsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbGlkQ2xhc3M7XG4gICAgfVxuICAgIGdldCBpbnZhbGlkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW52YWxpZENsYXNzO1xuICAgIH1cbiAgICBnZXQgaXNWaXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5lbC5vZmZzZXRXaWR0aCB8fCB0aGlzLmVsLm9mZnNldEhlaWdodCB8fCB0aGlzLmVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IGlzSW5wdXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9wdGlvbnMuaW5wdXRPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IHZhbGlkYXRpb25NZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQ/LnZhbGlkYXRpb25NZXNzYWdlIHx8ICcnO1xuICAgIH1cbiAgICBnZXQgdmFsaWRpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRpbnB1dD8udmFsaWRpdHk7XG4gICAgfVxuICAgIHNlbGVjdElucHV0KCkge1xuICAgICAgICBsZXQgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlucHV0T3B0aW9ucykge1xuICAgICAgICAgICAgc2VsZWN0b3IgKz0gJywgJyArIHRoaXMub3B0aW9ucy5pbnB1dE9wdGlvbnNXcmFwcGVyU2VsZWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQgPSBpbnB1dDtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlV3JhcHBlcigpO1xuICAgICAgICBpZiAodGhpcy5pc0lucHV0T3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gdGhpcy4kaW5wdXQ7XG4gICAgICAgICAgICAkaW5wdXQudmFsaWRhdGlvbk1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICRpbnB1dC5zZXRDdXN0b21WYWxpZGl0eSA9IChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICAkaW5wdXQudmFsaWRhdGlvbk1lc3NhZ2UgPSBTdHJpbmcobXNnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAkaW5wdXQuY2hlY2tWYWxpZGl0eSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0T3B0aW9uc1ZhbGlkaXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRFdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy4kaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnZhbGlkJywgKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0ludmFsaWRSZXNwb25zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5vcHRpb25zLmV2ZW50cztcbiAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJlcGFyZVdyYXBwZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IodGhpcy5lcnJvclNlbGVjdG9yKT8uY2xhc3NMaXN0Py5jb250YWlucygnaW52YWxpZC10b29sdGlwJykpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsKS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1ZhbGlkaXR5KCkge1xuICAgICAgICBpZiAoIXRoaXMuJGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kaW5wdXQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kaW5wdXQuaGFzQXR0cmlidXRlKCdbZGF0YS1ub3ZhbGlkYXRlXScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kaW5wdXQuY2xvc2VzdCgnW2RhdGEtbm92YWxpZGF0ZV0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICBsZXQgdmFsaWQgPSB0aGlzLiRpbnB1dC5jaGVja1ZhbGlkaXR5KCk7XG4gICAgICAgIGlmICh2YWxpZCAmJiB0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICB2YWxpZCA9IHRoaXMucnVuQ3VzdG9tVmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSYWlzZSBpbnZhbGlkIGV2ZW50XG4gICAgICAgIC8vIHRoaXMuJGlucHV0LmNoZWNrVmFsaWRpdHkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWxpZENsYXNzKHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBydW5DdXN0b21WYWxpZGl0eSgpIHtcbiAgICAgICAgLy8gQ2hlY2sgY3VzdG9tIHZhbGlkaXR5XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlcyA9ICh0aGlzLiRpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsaWRhdGUnKSB8fCAnJykuc3BsaXQoJ3wnKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiRpbnB1dC52YWx1ZSAhPT0gJycgJiYgdmFsaWRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ3VzdG9tRGF0YUF0dHJpYnV0ZVZhbGlkaXR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkYXRvck5hbWUgb2YgdmFsaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3ZhbGlkYXRvciwgb3B0aW9uc10gPSB0aGlzLmdldFZhbGlkYXRvcih2YWxpZGF0b3JOYW1lKSB8fCBbbnVsbCwge31dO1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHZhbGlkYXRvci5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBsZXQgciA9IHZhbGlkYXRvci5oYW5kbGVyKHRoaXMuJGlucHV0LnZhbHVlLCB0aGlzLiRpbnB1dCwgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgcmV0dXJuIGlzIGEgcHJvbWlzZSwgcHVzaCB0byBzdGFjayBhbmQgcmVzb2x2ZSBsYXRlclxuICAgICAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSB8fCAodHlwZW9mIHIgPT09ICdvYmplY3QnICYmIHIudGhlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgci50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXN5bmNDdXN0b21SZXN1bHQocmVzdWx0LCB2YWxpZGF0b3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYW5kbGVDdXN0b21SZXN1bHQociwgdmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNoZWNrVmFsaWRpdHlBc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGlucHV0Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICBsZXQgdmFsaWQgPSB0aGlzLiRpbnB1dC5jaGVja1ZhbGlkaXR5KCk7XG4gICAgICAgIGlmICh2YWxpZCAmJiB0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGF3YWl0IHRoaXMucnVuQ3VzdG9tVmFsaWRpdHlBc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRDbGFzcyh2YWxpZCk7XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgYXN5bmMgcnVuQ3VzdG9tVmFsaWRpdHlBc3luYygpIHtcbiAgICAgICAgLy8gQ2hlY2sgY3VzdG9tIHZhbGlkaXR5XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlcyA9ICh0aGlzLiRpbnB1dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsaWRhdGUnKSB8fCAnJykuc3BsaXQoJ3wnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy4kaW5wdXQudmFsdWUgIT09ICcnICYmIHZhbGlkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja0N1c3RvbURhdGFBdHRyaWJ1dGVWYWxpZGl0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWxpZGF0b3JOYW1lIG9mIHZhbGlkYXRlcykge1xuICAgICAgICAgICAgICAgIGxldCBbdmFsaWRhdG9yLCBvcHRpb25zXSA9IHRoaXMuZ2V0VmFsaWRhdG9yKHZhbGlkYXRvck5hbWUpIHx8IFtudWxsLCB7fV07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB2YWxpZGF0b3Iub3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChQcm9taXNlLnJlc29sdmUodmFsaWRhdG9yLmhhbmRsZXIodGhpcy4kaW5wdXQudmFsdWUsIHRoaXMuJGlucHV0LCBvcHRpb25zLCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuaGFuZGxlQXN5bmNDdXN0b21SZXN1bHQociwgdmFsaWRhdG9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjaGVja0N1c3RvbURhdGFBdHRyaWJ1dGVWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLiRpbnB1dC5kYXRhc2V0LnZhbGlkYXRpb25GYWlsO1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDdXN0b21SZXN1bHQoZXJyb3IpO1xuICAgIH1cbiAgICBjaGVja0lucHV0T3B0aW9uc1ZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCBpc1JlcXVpcmVkID0gdGhpcy4kaW5wdXQuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpICE9IG51bGw7XG4gICAgICAgIGNvbnN0IG9wdGlvbldyYXBwZXJzID0gdGhpcy4kaW5wdXQucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuaW5wdXRPcHRpb25zU2VsZWN0b3IpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uV3JhcHBlciBvZiBvcHRpb25XcmFwcGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gb3B0aW9uV3JhcHBlci5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgbmVlZCBvbmUgY2hlY2tlZFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dD8uY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGJyb3dzZXIgaW5wdXQgdmFsaWRhdGlvbiBtZXNzYWdlXG4gICAgICAgIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBuLnJlcXVpcmVkID0gaXNSZXF1aXJlZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgbi52YWx1ZSA9ICdwbGFjZWhvbGRlcic7XG4gICAgICAgIH1cbiAgICAgICAgbi5jaGVja1ZhbGlkaXR5KCk7XG4gICAgICAgIHRoaXMuJGlucHV0LnZhbGlkYXRpb25NZXNzYWdlID0gbi52YWxpZGF0aW9uTWVzc2FnZTtcbiAgICAgICAgdGhpcy4kaW5wdXQudmFsaWRpdHkgPSBuLnZhbGlkaXR5O1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbldyYXBwZXIgb2Ygb3B0aW9uV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gb3B0aW9uV3JhcHBlci5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXQ/LnNldEN1c3RvbVZhbGlkaXR5KG4udmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaW52YWxpZCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsaWQge2Jvb2xlYW59XG4gICAgICovXG4gICAgdXBkYXRlVmFsaWRDbGFzcyh2YWxpZCkge1xuICAgICAgICB0aGlzLiRpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuaW52YWxpZENsYXNzKTtcbiAgICAgICAgdGhpcy4kaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnZhbGlkQ2xhc3MpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5pbnZhbGlkQ2xhc3MpO1xuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy52YWxpZENsYXNzKTtcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMudmFsaWRDbGFzcyk7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy52YWxpZENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5pbnZhbGlkQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QuYWRkKHRoaXMuaW52YWxpZENsYXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRGb3JtVmFsaWRhdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRoZWxwZXIuZ2V0Qm91bmRlZEluc3RhbmNlKGVsZW1lbnQgfHwgdGhpcy5nZXRGb3JtKCksICdmb3JtLnZhbGlkYXRpb24nKTtcbiAgICB9XG4gICAgZ2V0VmFsaWRhdG9yKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IG5hbWUubWF0Y2goLyg/PHR5cGU+W1xcd1xcLV9dKykoXFwoKD88cGFyYW1zPi4qKVxcKSkqLyk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yTmFtZSA9IG1hdGNoZXMuZ3JvdXBzPy50eXBlIHx8ICcnO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBtYXRjaGVzLmdyb3Vwcz8ucGFyYW1zIHx8ICcnO1xuICAgICAgICBjb25zdCBmdiA9IHRoaXMuZ2V0Rm9ybVZhbGlkYXRpb24odGhpcy4kZm9ybSk7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGZ2Py52YWxpZGF0b3JzW3ZhbGlkYXRvck5hbWVdIHx8IFVuaWNvcm5Gb3JtVmFsaWRhdGlvbi5nbG9iYWxWYWxpZGF0b3JzW3ZhbGlkYXRvck5hbWVdO1xuICAgICAgICBpZiAoIXZhbGlkYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1NYXRjaGVzID0gcGFyYW1zLm1hdGNoQWxsKC8oPzxrZXk+XFx3KykoXFxzP1s9Ol1cXHM/KD88dmFsdWU+XFx3KykpPy9nKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtTWF0Y2ggb2YgcGFyYW1NYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHBhcmFtTWF0Y2g/Lmdyb3VwcztcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnNbbWF0Y2gua2V5XSA9IGhhbmRsZVBhcmFtVmFsdWUobWF0Y2gudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdmFsaWRhdG9yLCBvcHRpb25zXTtcbiAgICB9XG4gICAgaGFuZGxlQ3VzdG9tUmVzdWx0KHJlc3VsdCwgdmFsaWRhdG9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkocmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZUN1c3RvbUVycm9yU3RhdGUodmFsaWRhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoYW5kbGVBc3luY0N1c3RvbVJlc3VsdChyZXN1bHQsIHZhbGlkYXRvcikge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZUN1c3RvbVJlc3VsdChyZXN1bHQsIHZhbGlkYXRvcik7XG4gICAgICAgIC8vIEZpcmUgaW52YWxpZCBldmVudHNcbiAgICAgICAgdGhpcy4kaW5wdXQuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkQ2xhc3MocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmFpc2VDdXN0b21FcnJvclN0YXRlKHZhbGlkYXRvcikge1xuICAgICAgICBsZXQgaGVscDtcbiAgICAgICAgaWYgKHRoaXMuJGlucHV0LnZhbGlkYXRpb25NZXNzYWdlID09PSAnJykge1xuICAgICAgICAgICAgaGVscCA9IHZhbGlkYXRvci5vcHRpb25zPy5ub3RpY2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhlbHAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoZWxwID0gaGVscCh0aGlzLiRpbnB1dCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVscCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoaGVscCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJGlucHV0LnZhbGlkYXRpb25NZXNzYWdlID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkodGhpcy4kbGFuZy5fXygndW5pY29ybi5tZXNzYWdlLnZhbGlkYXRpb24uY3VzdG9tLmVycm9yJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpbnZhbGlkJykpO1xuICAgIH1cbiAgICBzZXRBc0ludmFsaWRBbmRSZXBvcnQoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zZXRDdXN0b21WYWxpZGl0eShlcnJvcik7XG4gICAgICAgIHRoaXMuc2hvd0ludmFsaWRSZXNwb25zZSgpO1xuICAgIH1cbiAgICBzZXRDdXN0b21WYWxpZGl0eShlcnJvcikge1xuICAgICAgICB0aGlzLiRpbnB1dC5zZXRDdXN0b21WYWxpZGl0eShlcnJvcik7XG4gICAgfVxuICAgIHJlcG9ydFZhbGlkaXR5KCkge1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0aW9uTWVzc2FnZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0ludmFsaWRSZXNwb25zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3dJbnZhbGlkUmVzcG9uc2UoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsaWRDbGFzcyhmYWxzZSk7XG4gICAgICAgIC8qKiBAdHlwZSBWYWxpZGl0eVN0YXRlICovXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy4kaW5wdXQudmFsaWRpdHk7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy4kaW5wdXQudmFsaWRhdGlvbk1lc3NhZ2U7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gJiYgdGhpcy4kaW5wdXQuZGF0YXNldFtrZXkgKyAnTWVzc2FnZSddKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuJGlucHV0LmRhdGFzZXRba2V5ICsgJ01lc3NhZ2UnXSB8fCAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSB0aGlzLmZpbmRMYWJlbCgpPy50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IHRoaXMuJGlucHV0Lm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiR1aS5yZW5kZXJNZXNzYWdlKGBGaWVsZDogJHt0aXRsZX0gLSAke21lc3NhZ2V9YCwgJ3dhcm5pbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgJGhlbHAgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IodGhpcy5lcnJvclNlbGVjdG9yKTtcbiAgICAgICAgaWYgKCEkaGVscCkge1xuICAgICAgICAgICAgJGhlbHAgPSB0aGlzLmNyZWF0ZUhlbHBFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKCRoZWxwKTtcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZVdyYXBwZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAkaGVscC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGNyZWF0ZUhlbHBFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlQ2xhc3M7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VTZWxlY3Rvcih0aGlzLmVycm9yU2VsZWN0b3IgfHwgJycpO1xuICAgICAgICBjb25zdCAkaGVscCA9IHRoaXMuJGhlbHBlci5odG1sKGA8ZGl2IGNsYXNzPVwiJHtjbGFzc05hbWV9XCI+PC9kaXY+YCk7XG4gICAgICAgICRoZWxwLmNsYXNzTGlzdC5hZGQoLi4ucGFyc2VkLmNsYXNzZXMpO1xuICAgICAgICBwYXJzZWQuYXR0cnMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICAgICAgJGhlbHAuc2V0QXR0cmlidXRlKGF0dHJbMF0sIGF0dHJbMV0gfHwgJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyc2VkLmlkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgJGhlbHAuaWQgPSBpZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAkaGVscDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTc4ODgxNzhcbiAgICAgKi9cbiAgICBwYXJzZVNlbGVjdG9yKHN1YnNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHsgdGFnczogW10sIGNsYXNzZXM6IFtdLCBpZHM6IFtdLCBhdHRyczogW10gfTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBzdWJzZWxlY3Rvci5zcGxpdCgvKD89XFwuKXwoPz0jKXwoPz1cXFspLykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLmlkcy5wdXNoKHRva2VuLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICAgIG9iai5jbGFzc2VzLnB1c2godG9rZW4uc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLmF0dHJzLnB1c2godG9rZW4uc2xpY2UoMSwgLTEpLnNwbGl0KCc9JykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmoudGFncy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgc2V0QXNWYWxpZEFuZENsZWFyUmVzcG9uc2UoKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbGlkQ2xhc3ModHJ1ZSk7XG4gICAgICAgIHRoaXMuY2xlYXJJbnZhbGlkUmVzcG9uc2UoKTtcbiAgICB9XG4gICAgY2xlYXJJbnZhbGlkUmVzcG9uc2UoKSB7XG4gICAgICAgIGNvbnN0ICRoZWxwID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKHRoaXMuZXJyb3JTZWxlY3Rvcik7XG4gICAgICAgICRoZWxwLnRleHRDb250ZW50ID0gJyc7XG4gICAgfVxuICAgIGdldEZvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsb3Nlc3QodGhpcy5vcHRpb25zLmZvcm1TZWxlY3RvciB8fCAnW3VuaS1mb3JtLXZhbGlkYXRlXScpO1xuICAgIH1cbiAgICBmaW5kTGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy4kaW5wdXQuaWQ7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLiRpbnB1dC5jbG9zZXN0KCdbZGF0YS1maWVsZC13cmFwcGVyXScpO1xuICAgICAgICBsZXQgbGFiZWwgPSBudWxsO1xuICAgICAgICBpZiAod3JhcHBlcikge1xuICAgICAgICAgICAgbGFiZWwgPSB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWZpZWxkLWxhYmVsXScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgICAgIGxhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGFiZWxbZm9yPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FtZWxUbyhzdHIsIHNlcCkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgYCQxJHtzZXB9JDJgKS50b0xvd2VyQ2FzZSgpO1xufVxudmFsaWRhdG9ySGFuZGxlcnMudXNlcm5hbWUgPSBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ1tcXDx8XFw+fFwifFxcJ3xcXCV8XFw7fFxcKHxcXCl8XFwmXScsICdpJyk7XG4gICAgcmV0dXJuICFyZWdleC50ZXN0KHZhbHVlKTtcbn07XG52YWxpZGF0b3JIYW5kbGVycy5udW1lcmljID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcmVnZXggPSAvXihcXGR8LSk/KFxcZHwsKSpcXC4/XFxkKiQvO1xuICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKTtcbn07XG52YWxpZGF0b3JIYW5kbGVycy5lbWFpbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCkge1xuICAgIHZhbHVlID0gcHVueWNvZGUudG9BU0NJSSh2YWx1ZSk7XG4gICAgY29uc3QgcmVnZXggPSAvXlthLXpBLVowLTkuISMkJSbDouKCrOKEoiorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTktXSsoPzpcXC5bYS16QS1aMC05LV0rKSokLztcbiAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSk7XG59O1xudmFsaWRhdG9ySGFuZGxlcnMudXJsID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcmVnZXggPSAvXig/Oig/Omh0dHBzP3xmdHApOlxcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ITEwKD86XFwuXFxkezEsM30pezN9KSg/ITEyNyg/OlxcLlxcZHsxLDN9KXszfSkoPyExNjlcXC4yNTQoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTkyXFwuMTY4KD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXHUwMGExLVxcdWZmZmYwLTldKy0/KSpbYS16XFx1MDBhMS1cXHVmZmZmMC05XSspKD86XFwuKD86W2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rLT8pKlthLXpcXHUwMGExLVxcdWZmZmYwLTldKykqKD86XFwuKD86W2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9KSkpKD86OlxcZHsyLDV9KT8oPzpcXC9bXlxcc10qKT8kL2k7XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpO1xufTtcbnZhbGlkYXRvckhhbmRsZXJzLmFsbnVtID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcmVnZXggPSAvXlthLXpBLVowLTldKiQvO1xuICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKTtcbn07XG52YWxpZGF0b3JIYW5kbGVycy5jb2xvciA9IGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCkge1xuICAgIGNvbnN0IHJlZ2V4ID0gL14jKD86WzAtOWEtZl17M30pezEsMn0kLztcbiAgICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBAc2VlICBodHRwOi8vd3d3LnZpcnR1b3NpbWVkaWEuY29tL2Rldi9waHAvMzctdGVzdGVkLXBocC1wZXJsLWFuZC1qYXZhc2NyaXB0LXJlZ3VsYXItZXhwcmVzc2lvbnNcbiAqL1xudmFsaWRhdG9ySGFuZGxlcnMuY3JlZGl0Y2FyZCA9IGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCkge1xuICAgIGNvbnN0IHJlZ2V4ID0gL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18NjAxMVswLTldezEyfXw2MjIoKDEyWzYtOV18MVszLTldWzAtOV0pfChbMi04XVswLTldWzAtOV0pfCg5KChbMC0xXVswLTldKXwoMlswLTVdKSkpKVswLTldezEwfXw2NFs0LTldWzAtOV17MTN9fDY1WzAtOV17MTR9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwzWzQ3XVswLTldezEzfSkqJC87XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpO1xufTtcbnZhbGlkYXRvckhhbmRsZXJzLmlwID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgY29uc3QgcmVnZXggPSAvXigoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPykpKiQvO1xuICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKTtcbn07XG52YWxpZGF0b3JIYW5kbGVyc1sncGFzc3dvcmQtY29uZmlybSddID0gZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBlbGVtZW50LmRhdGFzZXQuY29uZmlybVRhcmdldDtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsaWRhdG9yOiBcInBhc3N3b3JkLWNvbmZpcm1cIiBtdXN0IGFkZCBcImRhdGEtY29uZmlybS10YXJnZXRcIiBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIHJldHVybiB0YXJnZXQ/LnZhbHVlID09PSB2YWx1ZTtcbn07XG5leHBvcnQgeyB2YWxpZGF0b3JIYW5kbGVycyBhcyB2YWxpZGF0b3JzIH07XG4vLyBjdXN0b21FbGVtZW50cy5kZWZpbmUoVW5pY29ybkZvcm1WYWxpZGF0ZUVsZW1lbnQuaXMsIFVuaWNvcm5Gb3JtVmFsaWRhdGVFbGVtZW50KTtcbi8vIGN1c3RvbUVsZW1lbnRzLmRlZmluZShVbmljb3JuRmllbGRWYWxpZGF0ZUVsZW1lbnQuaXMsIFVuaWNvcm5GaWVsZFZhbGlkYXRlRWxlbWVudCk7XG5leHBvcnQgZnVuY3Rpb24gaW5pdFZhbGlkYXRpb25zKGFwcCkge1xuICAgIGNvbnN0IGRpcmVjdGl2ZSA9IGFwcC5pbmplY3QoJyRkaXJlY3RpdmUnKTtcbiAgICBjb25zdCBoZWxwZXIgPSBhcHAuaW5qZWN0KCckaGVscGVyJyk7XG4gICAgZGlyZWN0aXZlLnJlZ2lzdGVyKCdmb3JtLXZhbGlkYXRlJywge1xuICAgICAgICBtb3VudGVkKGVsLCBiaW5kaW5nKSB7XG4gICAgICAgICAgICBoZWxwZXIuZ2V0Qm91bmRlZEluc3RhbmNlKGVsLCAnZm9ybS52YWxpZGF0aW9uJywgKGVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5pY29ybkZvcm1WYWxpZGF0aW9uKGFwcCwgZWxlLCBKU09OLnBhcnNlKGJpbmRpbmcudmFsdWUgfHwgJ3t9JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gaGVscGVyLmdldEJvdW5kZWRJbnN0YW5jZShlbCwgJ2Zvcm0udmFsaWRhdGlvbicpO1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhKU09OLnBhcnNlKGJpbmRpbmcudmFsdWUgfHwgJ3t9JykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGlyZWN0aXZlLnJlZ2lzdGVyKCdmaWVsZC12YWxpZGF0ZScsIHtcbiAgICAgICAgbW91bnRlZChlbCwgYmluZGluZykge1xuICAgICAgICAgICAgaGVscGVyLmdldEJvdW5kZWRJbnN0YW5jZShlbCwgJ2ZpZWxkLnZhbGlkYXRpb24nLCAoZWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmljb3JuRmllbGRWYWxpZGF0aW9uKGFwcCwgZWxlLCBKU09OLnBhcnNlKGJpbmRpbmcudmFsdWUgfHwgJ3t9JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gaGVscGVyLmdldEJvdW5kZWRJbnN0YW5jZShlbCwgJ2ZpZWxkLnZhbGlkYXRpb24nKTtcbiAgICAgICAgICAgIGluc3RhbmNlPy5zZXRPcHRpb25zKEpTT04ucGFyc2UoYmluZGluZy52YWx1ZSB8fCAne30nKSB8fCB7fSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBhcmFtVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoIWlzTmFOKE51bWJlcih2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/modules/ui/validation-components.ts\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/modules/ui/validation-components.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});