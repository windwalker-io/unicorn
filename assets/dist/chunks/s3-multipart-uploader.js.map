{"version":3,"file":"s3-multipart-uploader.js","sources":["../../src/module/s3-multipart-uploader.ts"],"sourcesContent":["import { AxiosProgressEvent, AxiosResponseHeaders } from 'axios';\nimport { Mixin } from 'ts-mixer';\nimport { createQueue, useHttpClient } from '../composable';\nimport { EventHandler, EventMixin } from '../events';\nimport { route } from '../service';\nimport type { MaybePromise } from '../types';\nimport { mergeDeep } from '../utilities';\nimport { ApiReturn } from './http-client';\n\ndeclare type RoutingOptions = {\n  init: string;\n  sign: string;\n  complete: string;\n  abort: string;\n} | ((action: RouteActions) => MaybePromise<string>);\n\ndeclare type RouteActions = 'init' | 'sign' | 'complete' | 'abort';\ndeclare type RequestHandler = <T = Record<string, any>>(action: RouteActions, data: Record<string, any>) => Promise<T>;\n\nexport interface S3MultipartUploaderOptions {\n  profile?: string;\n  chunkSize: number;\n  concurrency: number;\n  leaveAlert?: boolean;\n  routes: RoutingOptions;\n  requestHandler?: RequestHandler;\n  onProgress?: ProgressEventHandler;\n  ACL?: string;\n  extra?: Record<string, any>;\n\n  // maxRetries?: number;\n  // endpoint: string;\n  // subfolder?: string;\n}\n\nconst defaultOptions: Partial<S3MultipartUploaderOptions> = {\n  chunkSize: 5 * 1024 * 1024, // 5MB\n  concurrency: 2,\n};\n\nexport interface S3MultipartUploaderRequestOptions {\n  onProgress?: ProgressEventHandler;\n  filename?: string;\n  ContentType?: string;\n  ContentDisposition?: string;\n  ACL?: 'public-read' | 'private' | 'authenticated-read' | 'public-read-write' | string;\n  extra?: Record<string, any>;\n}\n\nexport class S3MultipartUploader extends Mixin(EventMixin) {\n  options: S3MultipartUploaderOptions;\n\n  constructor(options: Partial<S3MultipartUploaderOptions>) {\n    super();\n    this.options = mergeDeep({}, defaultOptions, options);\n  }\n\n  async upload(\n    file: string | File | Blob,\n    path: string,\n    options: S3MultipartUploaderRequestOptions = {}\n  ): Promise<{ url: string; id: string; path: string; }> {\n    const extra: Record<string, any> = { ...(this.options.extra ?? {}), ...(options.extra ?? {}) };\n\n    if (typeof file === 'string') {\n      file = new Blob([file], { type: options['ContentType'] || 'text/plain' });\n    }\n\n    if (file instanceof Blob && !(file instanceof File)) {\n      if (path.endsWith('.{ext}')) {\n        throw new Error('If using Blob or file data string, you must provide a valid file extension in the path.');\n      }\n\n      file = new File([file], 'blob', { type: file.type });\n    }\n\n    if (file instanceof File) {\n      extra['ContentType'] = options['ContentType'] || file.type;\n    }\n\n    if (options.ACL || this.options.ACL) {\n      extra.ACL = options.ACL || this.options.ACL;\n    }\n\n    path = this.replaceExt(path, file);\n\n    const initData: Record<string, any> = { extra, path, profile: this.options.profile };\n\n    if (options['filename']) {\n      initData['filename'] = options['filename'];\n    }\n\n    this.trigger('start', file, initData);\n\n    // Prepare unload\n    const beforeUnloadHandler = (e: BeforeUnloadEvent) => {\n      e.preventDefault();\n      e.returnValue = '';\n    };\n    if (this.options.leaveAlert === true) {\n      window.addEventListener('beforeunload', beforeUnloadHandler);\n    }\n\n    // @Request init\n    const { id } = await this.request<{ id: string; }>(\n      'init',\n      initData\n    );\n\n    this.trigger('inited', { id, path });\n\n    try {\n      const chunkSize = this.options.chunkSize;\n      const chunks = Math.ceil(file.size / chunkSize);\n\n      let uploadedBytes = 0;\n      let parts: { ETag: string, PartNumber: number }[] = [];\n      let currentPart = 1;\n      const queue = createQueue(this.options.concurrency);\n      const promises = [];\n      const partsUploaded: Record<number, number> = {};\n\n      // Loop from 1 to chunks\n      while (currentPart <= chunks) {\n        const partNumber = currentPart;\n\n        // Push to queue\n        const p = queue.push(async () => {\n          const { blob, etag } = await this.uploadPart(\n            file as File,\n            {\n              id,\n              path,\n              partNumber,\n              chunkSize,\n              onUploadProgress: (e) => {\n                partsUploaded[partNumber] = e.loaded;\n\n                const uploaded = Object.values(partsUploaded).reduce((sum, a) => sum + a, 0);\n\n                this.updateProgress(uploaded, file.size, options);\n              }\n            }\n          );\n\n          uploadedBytes += blob.size;\n\n          // Use parts progress, ignore the overall progress, which may be inaccurate due to retries or concurrency\n          // this.updateProgress(uploadedBytes, file.size, options);\n\n          parts.push({ ETag: etag, PartNumber: partNumber });\n        });\n\n        promises.push(p);\n\n        currentPart++;\n      }\n\n      await Promise.all(promises);\n\n      // @Request sign\n      const { url } = await this.request<{ url: string }>(\n        'complete',\n        {\n          id,\n          path,\n          parts: parts.sort((a, b) => a.PartNumber - b.PartNumber),\n          profile: this.options.profile,\n        },\n      );\n\n      this.trigger('success', { id, path, url });\n\n      return { url, id, path };\n    } catch (e) {\n      await this.abort(id, path);\n\n      this.trigger('failure', { error: e as Error, id, path });\n\n      throw e;\n    } finally {\n      if (this.options.leaveAlert === true) {\n        window.removeEventListener('beforeunload', beforeUnloadHandler);\n      }\n    }\n  }\n\n  protected async uploadPart(\n    file: File,\n    payload: {\n      id: string;\n      path: string;\n      partNumber: number;\n      chunkSize: number;\n      onUploadProgress: (e: AxiosProgressEvent) => void;\n    }\n  ) {\n    const http = await useHttpClient();\n    const { id, path, partNumber, chunkSize, onUploadProgress } = payload;\n\n    const start = (partNumber - 1) * chunkSize;\n    const end = Math.min(partNumber * chunkSize, file.size);\n\n    const blob = file.slice(start, end);\n\n    // @Request sign\n    const { url } = await this.request<{ url: string; }>(\n      'sign',\n      {\n        id,\n        path,\n        partNumber,\n        profile: this.options.profile,\n      }\n    );\n\n    // PUT to S3\n    const res = await http.put(\n      url,\n      blob,\n      {\n        onUploadProgress,\n      }\n    );\n\n    const etag = String((res.headers as AxiosResponseHeaders).get('ETag') || '');\n\n    return { blob, etag };\n  }\n\n  protected async request<T = Record<string, any>>(action: RouteActions, body: Record<string, any>): Promise<T> {\n    if (this.options.requestHandler) {\n      return this.options.requestHandler<T>(action, body);\n    }\n\n    const http = await useHttpClient();\n\n    const res = await http.post<ApiReturn<T>>(await this.resolveRoute(action), body);\n\n    return res.data.data;\n  }\n\n  // protected async abortBeacon(id: string, path: string): Promise<void> {\n  //   const data = new FormData();\n  //   data.append('id', id);\n  //   data.append('path', path);\n  //   data.append('profile', this.options.profile || '');\n  //\n  //   await navigator.sendBeacon(route(await this.resolveRoute('abort')), data);\n  // }\n\n  async abort(id: string, path: string) {\n    await this.request(\n      'abort',\n      {\n        id,\n        path,\n        profile: this.options.profile,\n      }\n    );\n  }\n\n  updateProgress(loaded: number, total: number, options: S3MultipartUploaderRequestOptions) {\n    const percentage = (loaded / total) * 100;\n\n    const event: ProgressEvent = { percentage, loaded, total };\n\n    this.trigger('progress', event);\n\n    this.options.onProgress?.(event);\n\n    if (options.onProgress) {\n      options.onProgress(event);\n    }\n  }\n\n  async resolveRoute(action: RouteActions): Promise<string> {\n    if (typeof this.options.routes === 'function') {\n      return this.options.routes(action);\n    }\n\n    return this.options.routes[action];\n  }\n\n  setChunkSize(size: number): this {\n    this.options.chunkSize = size;\n\n    return this;\n  }\n\n  setChunkSizeInMiB(size: number): this {\n    this.options.chunkSize = size * 1024 * 1024;\n\n    return this;\n  }\n\n  replaceExt(path: string, file: File | Blob): string {\n    if (file instanceof File) {\n      const fileExt = file.name.split('.').pop();\n\n      if (path.endsWith('.{ext}')) {\n        return path.replace(/\\.{ext}$/, fileExt ? '.' + fileExt : '');\n      }\n    }\n\n    return path;\n  }\n\n  on(\n    event: 'start',\n    handler: (file: File, data: { path: string; extra: Record<string, any>; [name: string]: any; }) => void\n  ): this;\n  on(event: 'inited', handler: (event: { id: string; path: string; }) => void): this;\n  on(event: 'success', handler: (event: { url: string; id: string; path: string; }) => void): this;\n  on(event: 'progress', handler: (event: ProgressEvent) => void): this;\n  on(event: 'failure', handler: (event: { error: Error; id: string; path: string; }) => void): this;\n  on(event: string | string[], handler: EventHandler): this {\n    return super.on(event, handler);\n  }\n}\n\ntype ProgressEvent = {\n  percentage: number;\n  loaded: number;\n  total: number;\n};\ntype ProgressEventHandler = (e: ProgressEvent) => void;\n\nexport interface S3MultipartUploaderModule {\n  S3MultipartUploader: typeof S3MultipartUploader;\n}\n"],"names":[],"mappings":"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"}